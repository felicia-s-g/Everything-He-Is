<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punch Classification Debug</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #FAFAFA;
      display: flex;
      flex-direction: column;
      height: 80vh;
      color: #333;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 20px;
    }

    .visualization-container {
      flex: 1;
      background: white;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h1,
    h2,
    h3 {
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }

    #phone-container {
      width: 100%;
      height: 300px;
      position: relative;
    }

    #data-container {
      flex: 1;
      height: 700px;
      background-color: white;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow-y: auto;
    }

    .status {
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
    }

    .connected {
      background: #E6F4EA;
      color: #256029;
    }

    .disconnected {
      background: #FCE8E6;
      color: #A52714;
    }

    .message {
      padding: 10px;
      border-bottom: 1px solid #EEE;
      word-wrap: break-word;
      font-size: 14px;
      color: #555;
    }

    .timestamp {
      color: #AAA;
      font-size: 12px;
      padding-bottom: 2px;
    }

    .sensor-data {
      display: flex;
      justify-content: space-between;
      margin-top: 24px;
      width: 100%;
      background: #F8F9FA;
      padding: 12px;
      border-radius: 12px;
    }

    .sensor-value {
      text-align: center;
      flex: 1;
    }

    .sensor-value h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      color: #666;
    }

    .sensor-value p {
      margin: 5px 0;
      font-size: 20px;
      font-weight: 600;
      color: #222;
    }

    .trajectory-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .config-panel {
      margin-top: 20px;
      padding: 16px;
      background-color: #FFF;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      width: 100%;
    }

    .config-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .config-control {
      flex: 1 1 calc(33.33% - 16px);
      min-width: 150px;
    }

    .config-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .config-control input {
      width: 100%;
      padding: 8px;
      border: 1px solid #EEE;
      border-radius: 4px;
    }

    button {
      width: 100%;
      padding: 10px;
      background-color: #007BFF;
      color: #FFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 500;
    }

    button:hover {
      background-color: #0069d9;
    }

    .punch-visualization {
      margin-top: 24px;
      padding: 16px;
      background-color: #FFF;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      width: 100%;
    }

    .punch-meter {
      margin-bottom: 16px;
    }

    .punch-scale {
      display: flex;
      justify-content: space-between;
      position: relative;
      height: 30px;
      margin-top: 8px;
    }

    .punch-threshold {
      position: absolute;
      transform: translateX(-50%);
      font-weight: 500;
      font-size: 14px;
      top: 0;
    }

    .punch-threshold.weak {
      color: #28a745;
    }

    .punch-threshold.normal {
      color: #fd7e14;
    }

    .punch-threshold.strong {
      color: #dc3545;
    }

    .punch-bar-container {
      height: 20px;
      background-color: #EEE;
      border-radius: 10px;
      overflow: hidden;
    }

    .punch-bar {
      height: 100%;
      background-color: #007BFF;
      width: 0%;
    }

    .punch-bar.weak {
      background-color: #28a745;
    }

    .punch-bar.normal {
      background-color: #fd7e14;
    }

    .punch-bar.strong {
      background-color: #dc3545;
    }

    .punch-info {
      text-align: center;
    }

    .punch-info .weak {
      color: #28a745;
      font-weight: bold;
    }

    .punch-info .normal {
      color: #fd7e14;
      font-weight: bold;
    }

    .punch-info .strong {
      color: #dc3545;
      font-weight: bold;
    }

    .config-group {
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .config-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: #555;
    }

    .message-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .message-filters {
      display: flex;
      gap: 16px;
    }

    .message-filters label {
      display: flex;
      align-items: center;
    }

    .message-filters label input {
      margin-right: 8px;
    }

    .message-content {
      display: block;
    }

    /* Message type styling */
    .message-content.punch {
      font-weight: 500;
    }

    .message-content.punch-weak {
      color: #28a745;
      font-weight: bold;
    }

    .message-content.punch-normal {
      color: #fd7e14;
      font-weight: bold;
    }

    .message-content.punch-strong {
      color: #dc3545;
      font-weight: bold;
    }

    .message-content.system {
      color: #6c757d;
      font-style: italic;
    }

    .message-content.error {
      color: #dc3545;
      font-weight: bold;
    }

    .message-content.acceleration,
    .message-content.orientation {
      color: #6c757d;
      font-family: monospace;
      font-size: 0.9em;
    }

    /* Clear button styling */
    #clear-messages {
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
    }

    #clear-messages:hover {
      background-color: #5a6268;
    }

    .calibrate-button {
      margin-bottom: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .calibrate-button:hover {
      background-color: #45a049;
    }
  </style>
</head>

<body>
  <h1>Punch Classification Debug</h1>
  <div id="connection-status" class="status disconnected">Disconnected</div>

  <div class="container">
    <div class="visualization-container">
      <h2>Phone Orientation & Position</h2>
      <button id="calibrate-orientation" class="calibrate-button">Calibrate Orientation</button>
      <button id="reset-position" class="calibrate-button" style="background-color: #ff9800;">Reset Position</button>
      <div id="phone-container">
        <canvas id="trajectory-canvas" class="trajectory-canvas"></canvas>
      </div>

      <!-- Position data display -->
      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Position X</h3>
          <p id="position-x">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Position Y</h3>
          <p id="position-y">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Position Z</h3>
          <p id="position-z">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Trajectory Length</h3>
          <p id="trajectory-points">0</p>
        </div>
      </div>

      <!-- Punch Configuration Panel -->
      <div class="config-panel">
        <h3>Punch Classification Settings</h3>

        <div class="config-group">
          <div class="config-title">Threshold Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="weak-threshold">Weak Punch Threshold:</label>
              <input type="number" id="weak-threshold" value="3" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="normal-threshold">Normal Punch Threshold:</label>
              <input type="number" id="normal-threshold" value="6" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="strong-threshold">Strong Punch Threshold:</label>
              <input type="number" id="strong-threshold" value="15" min="0" step="0.5">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Detection Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="punch-cooldown">Punch Cooldown (ms):</label>
              <input type="number" id="punch-cooldown" value="100" min="0" step="10">
            </div>
            <div class="config-control">
              <label for="punch-max-value">Max Punch Value:</label>
              <input type="number" id="punch-max-value" value="40" min="1" step="1">
            </div>
            <div class="config-control">
              <label for="min-punch-threshold">Minimum Detection Threshold:</label>
              <input type="number" id="min-punch-threshold" value="2" min="0" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Acceleration Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="accel-weight-x">X-axis Weight:</label>
              <input type="number" id="accel-weight-x" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-y">Y-axis Weight:</label>
              <input type="number" id="accel-weight-y" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-z">Z-axis Weight:</label>
              <input type="number" id="accel-weight-z" value="1.0" min="0" max="10" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Direction Filter</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="direction-filter-enabled">Enable Direction Filter:</label>
              <select id="direction-filter-enabled">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
              </select>
            </div>
            <div class="config-control">
              <label for="direction-tolerance">Direction Tolerance (°):</label>
              <input type="number" id="direction-tolerance" value="45" min="0" max="180" step="5">
            </div>
            <div class="config-control">
              <label for="preferred-direction">Preferred Direction:</label>
              <select id="preferred-direction">
                <option value="positive-x">+X (Right)</option>
                <option value="negative-x">-X (Left)</option>
                <option value="positive-y">+Y (Up)</option>
                <option value="negative-y">-Y (Down)</option>
                <option value="positive-z">+Z (Forward)</option>
                <option value="negative-z">-Z (Backward)</option>
              </select>
            </div>
          </div>
        </div>

        <button id="apply-config">Apply Configuration</button>
      </div>

      <!-- Punch Classification Visualization -->
      <div class="punch-visualization">
        <h3>Punch Classification Visualization</h3>
        <div class="punch-meter">
          <div class="punch-bar-container">
            <div class="punch-bar" id="current-punch-strength"></div>
            <div class="punch-scale">
              <div class="punch-threshold weak" id="weak-threshold-indicator">Weak</div>
              <div class="punch-threshold normal" id="normal-threshold-indicator">Normal</div>
              <div class="punch-threshold strong" id="strong-threshold-indicator">Strong</div>
            </div>
          </div>
        </div>
        <div class="punch-info">
          <p>Last Punch: <span id="last-punch-value">None</span></p>
          <p>Classification: <span id="last-punch-classification">None</span></p>
        </div>
      </div>

      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Acceleration X</h3>
          <p id="accel-x">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Y</h3>
          <p id="accel-y">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Z</h3>
          <p id="accel-z">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Orientation Absolute</h3>
          <p id="orientation-absolute">false</p>
        </div>
      </div>
    </div>

    <div id="data-container">
      <div class="message-controls">
        <div class="message-filters">
          <label>
            <input type="checkbox" id="filter-punch" checked> Punches
          </label>
          <label>
            <input type="checkbox" id="filter-system" checked> System
          </label>
          <label>
            <input type="checkbox" id="filter-error" checked> Errors
          </label>
          <label>
            <input type="checkbox" id="filter-acceleration"> Acceleration
          </label>
          <label>
            <input type="checkbox" id="filter-orientation"> Orientation
          </label>
          <label>
            <input type="checkbox" id="filter-position"> Position
          </label>
        </div>
        <button id="clear-messages">Clear Messages</button>
      </div>
      <div id="message-list"></div>
    </div>
  </div>

  <script>
    const statusElement = document.getElementById('connection-status');
    const dataContainer = document.getElementById('data-container');
    const messageList = document.getElementById('message-list');
    const phoneContainer = document.getElementById('phone-container');

    // Sensor data display elements
    const accelXElement = document.getElementById('accel-x');
    const accelYElement = document.getElementById('accel-y');
    const accelZElement = document.getElementById('accel-z');
    const positionXElement = document.getElementById('position-x');
    const positionYElement = document.getElementById('position-y');
    const positionZElement = document.getElementById('position-z');
    const trajectoryPointsElement = document.getElementById('trajectory-points');

    let ws;

    // Last processed sensor data
    let lastSensorData = {
      acceleration: { x: 0, y: 0, z: 0 },
      orientation: { x: 0, y: 0, z: 0, absolute: false, _lastUpdate: 0 },
      position: { x: 0, y: 0, z: 0, _lastUpdate: 0 }
    };

    // Trajectory data
    let trajectoryPoints = [];
    let maxTrajectoryPoints = 1000;
    let trajectoryCanvas;
    let trajectoryContext;

    // Calibration quaternion
    let calibrationQuaternion = new THREE.Quaternion();
    let inverseCalibrationQuaternion = new THREE.Quaternion();
    let isCalibrated = false;

    // Punch visualization elements
    const punchBarElement = document.getElementById('current-punch-strength');
    const lastPunchValueElement = document.getElementById('last-punch-value');
    const lastPunchClassificationElement = document.getElementById('last-punch-classification');

    // Three.js variables
    let scene, camera, renderer, phoneModel;
    let isThreeJsInitialized = false;

    // Message throttling settings
    const messageThrottleTime = 500; // ms between sensor data updates
    let lastAccelerationMessageTime = 0;
    let lastOrientationMessageTime = 0;
    let sensorUpdatesSkipped = 0;

    // Message filter state
    const messageFilters = {
      punch: true,
      system: true,
      error: true,
      acceleration: false,
      orientation: false,
      position: false
    };

    // Initialize Three.js
    function initThreeJs() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(75, phoneContainer.clientWidth / phoneContainer.clientHeight, 0.1, 1000);
      camera.position.z = 7;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
      phoneContainer.appendChild(renderer.domElement);

      // Initialize trajectory canvas
      trajectoryCanvas = document.getElementById('trajectory-canvas');
      trajectoryCanvas.width = phoneContainer.clientWidth;
      trajectoryCanvas.height = phoneContainer.clientHeight;
      trajectoryContext = trajectoryCanvas.getContext('2d');

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      createPhoneModel();
      window.addEventListener('resize', onWindowResize);
      animate();
      isThreeJsInitialized = true;
    }

    // Create phone model
    function createPhoneModel() {
      const phoneGroup = new THREE.Group();
      scene.add(phoneGroup);

      // Phone body
      const phoneGeometry = new THREE.BoxGeometry(2, 4, 0.2);
      const phoneMaterial = new THREE.MeshPhongMaterial({
        color: 0x333333,
        shininess: 30
      });
      phoneModel = new THREE.Mesh(phoneGeometry, phoneMaterial);
      phoneGroup.add(phoneModel);

      // Store device position (will be updated from position events)
      phoneModel.userData.position = new THREE.Vector3(0, 0, 0);

      // Phone screen
      const screenGeometry = new THREE.BoxGeometry(1.8, 3.6, 0.01);
      const screenMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a1a,
        shininess: 100
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.11;
      phoneModel.add(screen);

      // Store the phone group for rotation updates
      phoneModel.userData.phoneGroup = phoneGroup;

      // Add coordinate axes to visualize orientation
      addDeviceCoordinateAxes(phoneGroup);
    }

    // Add coordinate axes to visualize device orientation
    function addDeviceCoordinateAxes(group) {
      const axisLength = 2.0;
      const axisWidth = 0.05;
      const axesGroup = new THREE.Group();
      group.add(axesGroup);

      // X-axis (red)
      const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
      xAxis.rotation.z = -Math.PI / 2;
      xAxis.position.x = axisLength / 2;
      axesGroup.add(xAxis);

      const xTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const xTip = new THREE.Mesh(xTipGeometry, xAxisMaterial);
      xTip.rotation.z = -Math.PI / 2;
      xTip.position.x = axisLength;
      axesGroup.add(xTip);

      // Y-axis (green)
      const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
      yAxis.position.y = axisLength / 2;
      axesGroup.add(yAxis);

      const yTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const yTip = new THREE.Mesh(yTipGeometry, yAxisMaterial);
      yTip.position.y = axisLength;
      axesGroup.add(yTip);

      // Z-axis (blue)
      const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
      const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
      zAxis.rotation.x = Math.PI / 2;
      zAxis.position.z = axisLength / 2;
      axesGroup.add(zAxis);

      const zTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const zTip = new THREE.Mesh(zTipGeometry, zAxisMaterial);
      zTip.rotation.x = Math.PI / 2;
      zTip.position.z = axisLength;
      axesGroup.add(zTip);

      // Add labels
      axesGroup.add(createLabel('X', new THREE.Vector3(axisLength + 0.3, 0, 0), '#ff0000'));
      axesGroup.add(createLabel('Y', new THREE.Vector3(0, axisLength + 0.3, 0), '#00ff00'));
      axesGroup.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.3), '#0000ff'));
    }

    // Create text label for axes
    function createLabel(text, position, color) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.font = 'Bold 48px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 32, 32);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.5, 0.5);
      sprite.position.copy(position);
      return sprite;
    }

    // Window resize handler
    function onWindowResize() {
      if (!isThreeJsInitialized) return;
      camera.aspect = phoneContainer.clientWidth / phoneContainer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update phone position in the scene if we have position data
      if (phoneModel && phoneModel.userData.phoneGroup) {
        // Apply the position from sensor data to the phone group
        const devicePosition = phoneModel.userData.position;
        phoneModel.userData.phoneGroup.position.copy(devicePosition);
      }

      renderer.render(scene, camera);
    }

    function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/debug`;

      console.log('Connecting to WebSocket at:', wsUrl);

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusElement.textContent = 'Connected';
        statusElement.classList.remove('disconnected');
        statusElement.classList.add('connected');
        addMessage({ type: 'system', message: 'Connected to server' });

        if (!isThreeJsInitialized) {
          initThreeJs();
        }

        // Request current configuration from server
        requestConfig();
      };

      ws.onclose = () => {
        statusElement.textContent = 'Disconnected - Reconnecting in 5 seconds...';
        statusElement.classList.remove('connected');
        statusElement.classList.add('disconnected');
        addMessage({ type: 'system', message: 'Disconnected from server' });
        setTimeout(connect, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addMessage({ type: 'error', message: 'WebSocket error occurred' });
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          processMessage(data);
          addMessage(data);
        } catch (error) {
          console.error('Error parsing message:', error);
          addMessage({ type: 'error', message: 'Error parsing message' });
        }
      };
    }

    function requestConfig() {
      // Try to get config via REST API first
      fetch('/api/config')
        .then(response => response.json())
        .then(data => {
          if (data && data.punch) {
            updateFormWithConfig(data.punch);
            addMessage({ type: 'system', message: 'Loaded configuration from REST API' });
          } else {
            // Fallback to WebSocket
            requestConfigViaWebSocket();
          }
        })
        .catch(error => {
          console.error('Error fetching config via REST:', error);
          // Fallback to WebSocket
          requestConfigViaWebSocket();
        });
    }

    function requestConfigViaWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'getConfig' }));
      }
    }

    function updateFormWithConfig(punchConfig) {
      // Update all configuration form values
      document.getElementById('weak-threshold').value = punchConfig.weakThreshold || 3;
      document.getElementById('normal-threshold').value = punchConfig.normalThreshold || 6;
      document.getElementById('strong-threshold').value = punchConfig.strongThreshold || 15;
      document.getElementById('punch-cooldown').value = punchConfig.coolDown || 100;
      document.getElementById('punch-max-value').value = punchConfig.maxValue || 40;
      document.getElementById('min-punch-threshold').value = punchConfig.minThreshold || 2;
      document.getElementById('accel-weight-x').value = punchConfig.accelWeights?.x || 1.0;
      document.getElementById('accel-weight-y').value = punchConfig.accelWeights?.y || 1.0;
      document.getElementById('accel-weight-z').value = punchConfig.accelWeights?.z || 1.0;
      document.getElementById('direction-filter-enabled').value =
        (punchConfig.directionFilter?.enabled !== undefined) ?
          punchConfig.directionFilter.enabled.toString() : "true";
      document.getElementById('direction-tolerance').value = punchConfig.directionFilter?.tolerance || 45;
      document.getElementById('preferred-direction').value = punchConfig.directionFilter?.direction || "positive-x";

      // Update the visual indicators
      updatePunchThresholds();
    }

    function processMessage(data) {
      // Check if the message is sensor data (acceleration or orientation)
      if (data.type === 'acceleration' && data.acceleration) {
        lastSensorData.acceleration = {
          x: data.acceleration.x,
          y: data.acceleration.y,
          z: data.acceleration.z
        };

        accelXElement.textContent = lastSensorData.acceleration.x.toFixed(2);
        accelYElement.textContent = lastSensorData.acceleration.y.toFixed(2);
        accelZElement.textContent = lastSensorData.acceleration.z.toFixed(2);
      }
      else if (data.type === 'orientation' && data.orientation) {
        processOrientationData(data.orientation);
        updatePhoneVisualization();
      }
      // Handle position data
      else if (data.type === 'position' && data.position) {
        processPositionData(data.position);
      }
      // Handle punch data
      else if (data.type === 'punch') {
        lastPunchValueElement.textContent = data.acceleration ? data.acceleration.toFixed(2) : 'N/A';
        lastPunchClassificationElement.textContent = data.classification || 'Unknown';
        lastPunchClassificationElement.className = '';
        lastPunchClassificationElement.classList.add(data.classification || 'unknown');

        // Get max value from the input field
        const maxValue = parseFloat(document.getElementById('punch-max-value').value);
        const percentage = Math.min(((data.acceleration || 0) / maxValue) * 100, 100);
        punchBarElement.style.width = `${percentage}%`;

        punchBarElement.className = 'punch-bar';
        if (data.classification) {
          punchBarElement.classList.add(data.classification);
        }

        punchBarElement.style.transition = 'width 0.1s linear';
        setTimeout(() => {
          punchBarElement.style.transition = 'width 2s ease-in-out';
          punchBarElement.style.width = '0%';
        }, 100);
      }
      // Handle system message with config update
      else if (data.type === 'system' && data.punchConfig) {
        updateFormWithConfig(data.punchConfig);
      }
    }

    // Process orientation data to handle edge cases
    function processOrientationData(orientation) {
      lastSensorData.orientation = {
        x: orientation.x,
        y: orientation.y,
        z: orientation.z,
        absolute: orientation.absolute,
        _lastUpdate: Date.now()
      };

      // Update the absolute flag display
      document.getElementById('orientation-absolute').textContent = orientation.absolute;
    }

    function updatePhoneVisualization() {
      if (!isThreeJsInitialized || !phoneModel) return;

      const phoneGroup = phoneModel.userData.phoneGroup;
      if (!phoneGroup) return;

      // Get the orientation values
      const alpha = lastSensorData.orientation.x;
      const beta = lastSensorData.orientation.y;
      const gamma = lastSensorData.orientation.z;

      // Convert to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // Create quaternion from device orientation
      const deviceQuaternion = new THREE.Quaternion()
        .setFromEuler(new THREE.Euler(
          -betaRad,
          gammaRad,
          -alphaRad,
          'ZXY'
        ));

      // Reset rotation
      phoneGroup.rotation.set(0, 0, 0);

      // Apply calibration if needed
      if (isCalibrated && !lastSensorData.orientation.absolute) {
        // Apply inverse calibration quaternion to "zero" the rotation
        // We need to use multiply instead of premultiply to maintain proper handedness for Z rotation
        const calibratedQuaternion = deviceQuaternion.clone().multiply(inverseCalibrationQuaternion);
        phoneGroup.quaternion.copy(calibratedQuaternion);
      } else {
        // Use raw device orientation
        phoneGroup.quaternion.copy(deviceQuaternion);
      }
    }

    // Process position data and update visualization
    function processPositionData(position) {
      // Update position data
      lastSensorData.position = {
        x: position.x,
        y: position.y,
        z: position.z,
        _lastUpdate: Date.now()
      };

      // Update position display
      positionXElement.textContent = position.x.toFixed(2);
      positionYElement.textContent = position.y.toFixed(2);
      positionZElement.textContent = position.z.toFixed(2);

      // Update the phone model position
      if (phoneModel) {
        phoneModel.userData.position.set(position.x, position.y, position.z);

        // Add point to trajectory
        addTrajectoryPoint(position.x, position.y, position.z);
      }
    }

    // Add a point to the trajectory and update visualization
    function addTrajectoryPoint(x, y, z) {
      trajectoryPoints.push({ x, y, z });

      // Limit the number of trajectory points
      if (trajectoryPoints.length > maxTrajectoryPoints) {
        trajectoryPoints.shift();
      }

      trajectoryPointsElement.textContent = trajectoryPoints.length;

      // Update trajectory visualization
      drawTrajectory();
    }

    // Draw the trajectory on the canvas
    function drawTrajectory() {
      if (!trajectoryContext || trajectoryPoints.length < 2) return;

      // Clear the canvas
      trajectoryContext.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);

      // Set drawing style
      trajectoryContext.strokeStyle = 'rgba(255, 140, 0, 0.8)';
      trajectoryContext.lineWidth = 2;
      trajectoryContext.beginPath();

      // Get first point and project it to screen coordinates
      const start = trajectoryPoints[0];
      const startVector = new THREE.Vector3(start.x, start.y, start.z);
      const startProjected = projectToScreen(startVector);

      trajectoryContext.moveTo(startProjected.x, startProjected.y);

      // Draw lines between all points
      for (let i = 1; i < trajectoryPoints.length; i++) {
        const point = trajectoryPoints[i];
        const vector = new THREE.Vector3(point.x, point.y, point.z);
        const projected = projectToScreen(vector);

        trajectoryContext.lineTo(projected.x, projected.y);
      }

      trajectoryContext.stroke();
    }

    // Project 3D position to screen coordinates
    function projectToScreen(position) {
      const vector = position.clone();
      vector.project(camera);

      return {
        x: (vector.x * 0.5 + 0.5) * trajectoryCanvas.width,
        y: (-vector.y * 0.5 + 0.5) * trajectoryCanvas.height
      };
    }

    // Reset device position and trajectory
    function resetPosition() {
      // Clear trajectory
      trajectoryPoints = [];
      trajectoryPointsElement.textContent = '0';

      if (trajectoryContext) {
        trajectoryContext.clearRect(0, 0, trajectoryCanvas.width, trajectoryCanvas.height);
      }

      // Reset position data
      lastSensorData.position = { x: 0, y: 0, z: 0, _lastUpdate: Date.now() };

      // Update position display
      positionXElement.textContent = '0.00';
      positionYElement.textContent = '0.00';
      positionZElement.textContent = '0.00';

      // Reset phone model position
      if (phoneModel && phoneModel.userData.phoneGroup) {
        phoneModel.userData.position.set(0, 0, 0);
        phoneModel.userData.phoneGroup.position.set(0, 0, 0);
      }

      // Send reset command to server
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'resetPosition' }));
        addMessage({ type: 'system', message: 'Position reset requested' });
      }
    }

    function addMessage(data) {
      const now = Date.now();

      // Throttle frequent sensor data messages
      if (data.type === 'acceleration') {
        if (now - lastAccelerationMessageTime < messageThrottleTime) {
          sensorUpdatesSkipped++;
          return;
        }
        lastAccelerationMessageTime = now;
        if (sensorUpdatesSkipped > 0) {
          addMessage({
            type: 'system',
            message: `Skipped ${sensorUpdatesSkipped} acceleration updates`
          });
          sensorUpdatesSkipped = 0;
        }
      } else if (data.type === 'orientation') {
        if (now - lastOrientationMessageTime < messageThrottleTime) {
          return;
        }
        lastOrientationMessageTime = now;
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      messageDiv.dataset.type = data.type;

      // Apply visibility based on current filters
      if (!messageFilters[data.type]) {
        messageDiv.style.display = 'none';
      }

      const timestamp = data.timestamp || new Date().toISOString();
      let content = '';
      let messageClass = data.type;

      if (data.type === 'acceleration') {
        content = `Accel: x=${data.acceleration.x.toFixed(2)}, y=${data.acceleration.y.toFixed(2)}, z=${data.acceleration.z.toFixed(2)}`;
      } else if (data.type === 'orientation') {
        content = `Orient: α=${data.orientation.x.toFixed(2)}°, β=${data.orientation.y.toFixed(2)}°, γ=${data.orientation.z.toFixed(2)}°, abs=${data.orientation.absolute}`;
      } else if (data.type === 'punch') {
        messageClass += data.classification ? ` punch-${data.classification}` : '';
        content = `Punch: ${data.classification || ''} (${data.acceleration ? data.acceleration.toFixed(2) : 'N/A'})`;
      } else if (data.type === 'error' && data.message) {
        content = `Error: ${data.message}`;
      } else if (data.type === 'system' && data.message) {
        content = data.message;
      } else {
        content = JSON.stringify(data, null, 2);
      }

      messageDiv.innerHTML = `
        <div class="timestamp">${new Date(timestamp).toLocaleTimeString('en-US', { hour12: false })}</div>
        <div class="message-content ${messageClass}">${content}</div>
      `;

      messageList.insertBefore(messageDiv, messageList.firstChild);

      // Keep only last 100 messages
      if (messageList.children.length > 100) {
        messageList.removeChild(messageList.lastChild);
      }
    }

    // Initial connection
    connect();

    // Setup punch configuration controls
    const applyConfigButton = document.getElementById('apply-config');
    applyConfigButton.addEventListener('click', () => {
      const punchConfig = {
        weakThreshold: parseFloat(document.getElementById('weak-threshold').value),
        normalThreshold: parseFloat(document.getElementById('normal-threshold').value),
        strongThreshold: parseFloat(document.getElementById('strong-threshold').value),
        coolDown: parseInt(document.getElementById('punch-cooldown').value),
        maxValue: parseFloat(document.getElementById('punch-max-value').value),
        minThreshold: parseFloat(document.getElementById('min-punch-threshold').value),
        accelWeights: {
          x: parseFloat(document.getElementById('accel-weight-x').value),
          y: parseFloat(document.getElementById('accel-weight-y').value),
          z: parseFloat(document.getElementById('accel-weight-z').value)
        },
        directionFilter: {
          enabled: document.getElementById('direction-filter-enabled').value === "true",
          tolerance: parseFloat(document.getElementById('direction-tolerance').value),
          direction: document.getElementById('preferred-direction').value
        }
      };

      updatePunchThresholds();

      // Use the REST API endpoint first, fallback to WebSocket if it fails
      fetch('/api/config', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ punch: punchConfig })
      })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            addMessage({ type: 'system', message: 'Punch configuration updated via REST API' });
          } else {
            // Fallback to WebSocket
            sendConfigViaWebSocket(punchConfig);
          }
        })
        .catch(error => {
          console.error('Error updating config via REST:', error);
          // Fallback to WebSocket
          sendConfigViaWebSocket(punchConfig);
        });
    });

    function sendConfigViaWebSocket(punchConfig) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'config',
          punchConfig
        }));
        addMessage({ type: 'system', message: 'Punch configuration sent via WebSocket' });
      } else {
        addMessage({ type: 'error', message: 'WebSocket not connected. Cannot send configuration.' });
      }
    }

    // Initialize punch threshold visualization
    updatePunchThresholds();

    // Add input event listeners to update visualizations in real-time
    document.getElementById('weak-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('normal-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('strong-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('punch-max-value').addEventListener('input', updatePunchThresholds);

    // Function to update the punch threshold visualization
    function updatePunchThresholds() {
      const weakThreshold = parseFloat(document.getElementById('weak-threshold').value);
      const normalThreshold = parseFloat(document.getElementById('normal-threshold').value);
      const strongThreshold = parseFloat(document.getElementById('strong-threshold').value);
      const maxValue = parseFloat(document.getElementById('punch-max-value').value);

      const weakIndicator = document.getElementById('weak-threshold-indicator');
      const normalIndicator = document.getElementById('normal-threshold-indicator');
      const strongIndicator = document.getElementById('strong-threshold-indicator');

      weakIndicator.style.left = `${(weakThreshold / maxValue) * 100}%`;
      normalIndicator.style.left = `${(normalThreshold / maxValue) * 100}%`;
      strongIndicator.style.left = `${(strongThreshold / maxValue) * 100}%`;
    }

    // Set up message filter controls
    document.getElementById('filter-punch').addEventListener('change', (e) => {
      messageFilters.punch = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-system').addEventListener('change', (e) => {
      messageFilters.system = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-error').addEventListener('change', (e) => {
      messageFilters.error = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-acceleration').addEventListener('change', (e) => {
      messageFilters.acceleration = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-orientation').addEventListener('change', (e) => {
      messageFilters.orientation = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-position').addEventListener('change', (e) => {
      messageFilters.position = e.target.checked;
      updateMessageVisibility();
    });

    document.getElementById('clear-messages').addEventListener('click', () => {
      messageList.innerHTML = '';
      addMessage({ type: 'system', message: 'Messages cleared' });
    });

    function updateMessageVisibility() {
      const messages = messageList.querySelectorAll('.message');
      messages.forEach(message => {
        const msgType = message.dataset.type;
        message.style.display = messageFilters[msgType] ? 'block' : 'none';
      });
    }

    // Add calibration button handler
    document.getElementById('calibrate-orientation').addEventListener('click', calibrateOrientation);

    function calibrateOrientation() {
      if (!lastSensorData.orientation) return;

      // Get current orientation values
      const alpha = lastSensorData.orientation.x;
      const beta = lastSensorData.orientation.y;
      const gamma = lastSensorData.orientation.z;

      // Convert to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // Create calibration quaternion from current orientation
      calibrationQuaternion.setFromEuler(new THREE.Euler(
        -betaRad,
        gammaRad,
        -alphaRad,
        'ZXY'
      ));

      // Create inverse quaternion for calibration
      inverseCalibrationQuaternion.copy(calibrationQuaternion).invert();

      isCalibrated = true;

      // After calibration, reset the phone's visual orientation
      if (phoneModel && phoneModel.userData.phoneGroup) {
        phoneModel.userData.phoneGroup.quaternion.identity();
      }

      addMessage({
        type: 'system',
        message: `Orientation calibrated using quaternions`
      });
    }

    // Add reset position button handler
    document.getElementById('reset-position').addEventListener('click', resetPosition);
  </script>
</body>

</html>
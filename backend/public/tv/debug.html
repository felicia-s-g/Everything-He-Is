<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punch Classification Debug</title>
  <script src="/js/three.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1C1C1E;
      display: flex;
      flex-direction: column;
      height: 80vh;
      color: #F2F2F7;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 20px;
    }

    .visualization-container {
      flex: 1;
      background: #2C2C2E;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h1,
    h2,
    h3 {
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }

    #phone-container {
      width: 100%;
      height: 300px;
      position: relative;
    }

    #data-container {
      flex: 1;
      height: 700px;
      background-color: #2C2C2E;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .status {
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
    }

    .connected {
      background: #34C759;
      color: #1C1C1E;
    }

    .disconnected {
      background: #FF3B30;
      color: #1C1C1E;
    }

    .message {
      padding: 10px;
      border-bottom: 1px solid #3A3A3C;
      word-wrap: break-word;
      font-size: 14px;
      color: #F2F2F7;
    }

    .timestamp {
      color: #8E8E93;
      font-size: 12px;
      padding-bottom: 2px;
    }

    .sensor-data {
      display: flex;
      justify-content: space-between;
      margin-top: 24px;
      margin-bottom: 24px;
      width: 100%;
      background: #3A3A3C;
      padding: 12px;
      border-radius: 12px;
    }

    .sensor-value {
      text-align: center;
      flex: 1;
    }

    .sensor-value h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      color: #8E8E93;
    }

    .sensor-value p {
      margin: 5px 0;
      font-size: 20px;
      font-weight: 600;
      color: #F2F2F7;
    }

    .config-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .config-control {
      flex: 1 1 calc(33.33% - 16px);
      min-width: 150px;
    }

    .config-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .config-control input {
      width: 100%;
      padding: 8px;
      border: 1px solid #3A3A3C;
      border-radius: 4px;
      background-color: #1C1C1E;
      color: #F2F2F7;
    }

    button {
      width: 100%;
      padding: 10px;
      background-color: #007BFF;
      color: #F2F2F7;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 500;
    }

    button:hover {
      background-color: #0069d9;
    }

    .punch-meter {
      margin-bottom: 16px;
    }

    .punch-scale {
      display: flex;
      justify-content: space-between;
      position: relative;
      height: 30px;
      margin-top: 8px;
    }

    .punch-threshold {
      position: absolute;
      transform: translateX(-50%);
      font-weight: 500;
      font-size: 14px;
      top: 0;
    }

    .punch-threshold.weak {
      color: #34C759;
    }

    .punch-threshold.normal {
      color: #FF9500;
    }

    .punch-threshold.strong {
      color: #FF3B30;
    }

    .punch-bar-container {
      height: 20px;
      background-color: #3A3A3C;
      border-radius: 10px;
      overflow: hidden;
    }

    .punch-bar {
      height: 100%;
      background-color: #007BFF;
      width: 0%;
    }

    .punch-bar.weak {
      background-color: #34C759;
    }

    .punch-bar.normal {
      background-color: #FF9500;
    }

    .punch-bar.strong {
      background-color: #FF3B30;
    }

    .punch-info {
      text-align: center;
    }

    .punch-info .weak {
      color: #34C759;
      font-weight: bold;
    }

    .punch-info .normal {
      color: #FF9500;
      font-weight: bold;
    }

    .punch-info .strong {
      color: #FF3B30;
      font-weight: bold;
    }

    .config-group {
      border: 1px solid #3A3A3C;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .config-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: #8E8E93;
    }

    .message-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .message-filters {
      display: flex;
      gap: 16px;
    }

    .message-filters label {
      display: flex;
      align-items: center;
    }

    .message-filters label input {
      margin-right: 8px;
    }

    .message-content {
      display: block;
    }

    .message-content.punch {
      font-weight: 500;
    }

    .message-content.punch-weak {
      color: #34C759;
      font-weight: bold;
    }

    .message-content.punch-normal {
      color: #FF9500;
      font-weight: bold;
    }

    .message-content.punch-strong {
      color: #FF3B30;
      font-weight: bold;
    }

    .message-content.system {
      color: #8E8E93;
      font-style: italic;
    }

    .message-content.error {
      color: #FF3B30;
      font-weight: bold;
    }

    .message-content.acceleration,
    .message-content.orientation {
      color: #8E8E93;
      font-family: monospace;
      font-size: 0.9em;
    }

    #clear-messages {
      background-color: #6c757d;
      color: #F2F2F7;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
    }

    #clear-messages:hover {
      background-color: #5a6268;
    }

    .calibrate-button {
      margin-bottom: 16px;
      background-color: #34C759;
      color: #1C1C1E;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .calibrate-button:hover {
      background-color: #28A745;
    }

    .collapsible .collapsible-content {
      display: none;
      overflow: hidden;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
    }

    .collapsible.active .collapsible-content {
      display: block;
    }

    .panel-title {
      cursor: pointer;
      font-weight: bold;
      padding: 10px;
      background: #2C2C2E;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s ease-in-out;
    }

    .panel-title:hover {
      background: #3A3A3C;
    }

    .toggle-icon {
      font-size: 16px;
      font-weight: bold;
    }

    .clear-button {
      background-color: #6c757d;
      color: #F2F2F7;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
      float: right;
    }

    .clear-button:hover {
      background-color: #5a6268;
    }
  </style>
</head>

<body>
  <h1>Punch Classification Debug</h1>
  <div id="connection-status" class="status disconnected">Disconnected</div>

  <div class="container">
    <div class="visualization-container">
      <h2>Phone Orientation</h2>

      <!-- Add source ID dropdown -->
      <div style="width: 100%; margin-bottom: 16px;">
        <label for="source-id-selector" style="display: block; margin-bottom: 8px;">Source ID:</label>
        <select id="source-id-selector" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #3A3A3C; background-color: #1C1C1E; color: #F2F2F7;">
          <option value="all">All Sources</option>
          <!-- Source IDs will be populated dynamically -->
        </select>
      </div>

      <button id="calibrate-visualization" class="calibrate-button">Calibrate Orientation</button>
      <div id="phone-container"></div>

      <!-- Punch Configuration Panel -->
      <div class="config-panel">
        <h3>Punch Classification Settings</h3>

        <div class="config-group">
          <div class="config-title">Threshold Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="weak-threshold">Weak Punch Threshold:</label>
              <input type="number" id="weak-threshold" value="3" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="normal-threshold">Normal Punch Threshold:</label>
              <input type="number" id="normal-threshold" value="6" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="strong-threshold">Strong Punch Threshold:</label>
              <input type="number" id="strong-threshold" value="15" min="0" step="0.5">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Detection Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="punch-cooldown">Punch Cooldown (ms):</label>
              <input type="number" id="punch-cooldown" value="100" min="0" step="10">
            </div>
            <div class="config-control">
              <label for="punch-max-value">Max Punch Value:</label>
              <input type="number" id="punch-max-value" value="40" min="1" step="1">
            </div>
            <div class="config-control">
              <label for="min-punch-threshold">Minimum Detection Threshold:</label>
              <input type="number" id="min-punch-threshold" value="2" min="0" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Acceleration Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="accel-weight-x">X-axis Weight:</label>
              <input type="number" id="accel-weight-x" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-y">Y-axis Weight:</label>
              <input type="number" id="accel-weight-y" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-z">Z-axis Weight:</label>
              <input type="number" id="accel-weight-z" value="1.0" min="0" max="10" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Direction Filter</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="direction-filter-enabled">Enable Direction Filter:</label>
              <select id="direction-filter-enabled">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
              </select>
            </div>
            <div class="config-control">
              <label for="direction-tolerance">Direction Tolerance (°):</label>
              <input type="number" id="direction-tolerance" value="45" min="0" max="180" step="5">
            </div>
            <div class="config-control">
              <label for="preferred-direction">Preferred Direction:</label>
              <select id="preferred-direction">
                <option value="positive-x">+X (Right)</option>
                <option value="negative-x">-X (Left)</option>
                <option value="positive-y">+Y (Up)</option>
                <option value="negative-y">-Y (Down)</option>
                <option value="positive-z">+Z (Forward)</option>
                <option value="negative-z">-Z (Backward)</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Add new config group for photo scrolling -->
        <div class="config-group">
          <div class="config-title">Photo Scrolling Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="scroll-base-multiplier">Base Scroll Multiplier:</label>
              <input type="number" id="scroll-base-multiplier" value="1.0" min="0.1" max="10" step="0.1">
              <small>Controls overall scrolling speed for all punch strengths</small>
            </div>
            <div class="config-control">
              <label for="scroll-scaling-factor">Scaling Factor:</label>
              <input type="number" id="scroll-scaling-factor" value="0.2" min="0.05" max="2" step="0.05">
              <small>Controls how punch strength affects number of photos scrolled (higher = more photos per punch
                strength)</small>
            </div>
            <div class="config-control">
              <label for="scroll-max-photos">Maximum Photos:</label>
              <input type="number" id="scroll-max-photos" value="10" min="1" max="50" step="1">
              <small>Maximum number of photos to scroll per punch, regardless of strength</small>
            </div>
          </div>
        </div>

        <button id="apply-config">Apply Configuration</button>

        <div class="punch-visualization">
          <h3>Photo Scrolling Preview</h3>
          <div class="punch-info">
            <p>For a <span class="weak">weak</span> punch: <span id="weak-photo-count">0</span> photos</p>
            <p>For a <span class="normal">normal</span> punch: <span id="normal-photo-count">0</span> photos</p>
            <p>For a <span class="strong">strong</span> punch: <span id="strong-photo-count">0</span> photos</p>
          </div>
        </div>

        <div id="orientation-guide" class="config-panel" style="margin-top: 16px;">
          <h3>Device Orientation Guide</h3>
          <div style="display: flex; flex-wrap: wrap; gap: 16px;">
            <div style="flex: 1; min-width: 200px;">
              <h4>Device Axes</h4>
              <ul>
                <li><strong style="color:#ff0000">X-axis (Red):</strong> Left/Right</li>
                <li><strong style="color:#00ff00">Y-axis (Green):</strong> Up/Down</li>
                <li><strong style="color:#0000ff">Z-axis (Blue):</strong> Forward/Backward</li>
              </ul>
            </div>
            <div style="flex: 1; min-width: 200px;">
              <h4>Rotation Angles</h4>
              <ul>
                <li><strong>α (alpha):</strong> Rotation around Z-axis (compass)</li>
                <li><strong>β (beta):</strong> Rotation around X-axis (tilt forward/back)</li>
                <li><strong>γ (gamma):</strong> Rotation around Y-axis (tilt left/right)</li>
              </ul>
            </div>
          </div>
          <div style="margin-top: 10px;">
            <p><small>When the device is in its standard orientation, α=0° points north, β=0° is level with horizon, γ=0°
                is upright.</small></p>
          </div>
        </div>
      </div>
    </div>

    <div id="data-container" class="collapsible">  
       <!-- Punch Classification Visualization -->
       <div class="punch-visualization">
        <h3>Punch Classification Visualization</h3>
        <div class="punch-meter">
          <div class="punch-bar-container">
            <div class="punch-bar" id="current-punch-strength"></div>
            <div class="punch-scale">
              <div class="punch-threshold weak" id="weak-threshold-indicator">Weak</div>
              <div class="punch-threshold normal" id="normal-threshold-indicator">Normal</div>
              <div class="punch-threshold strong" id="strong-threshold-indicator">Strong</div>
            </div>
          </div>
        </div>
        <div class="punch-info">
          <p>Last Punch: <span id="last-punch-value">None</span></p>
          <p>Classification: <span id="last-punch-classification">None</span></p>
        </div>
      </div>

      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Acceleration X</h3>
          <p id="accel-x">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Y</h3>
          <p id="accel-y">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Z</h3>
          <p id="accel-z">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Orientation Absolute</h3>
          <p id="orientation-absolute">false</p>
        </div>
      </div>
      <div id="data-container" class="collapsible">  <div class="panel-title" onclick="togglePanel(this)">Debug Data & Photo Scrolling Preview <span class="toggle-icon">+</span></div>  <div class="collapsible-content">      <div class="message-controls">
        <div class="message-filters">
          <label>
            <input type="checkbox" id="filter-punch" checked> Punches
          </label>
          <label>
            <input type="checkbox" id="filter-system" checked> System
          </label>
          <label>
            <input type="checkbox" id="filter-error" checked> Errors
          </label>
          <label>
            <input type="checkbox" id="filter-acceleration"> Acceleration
          </label>
          <label>
            <input type="checkbox" id="filter-orientation"> Orientation
          </label>
  </div>        </div>
    <button id="clear-messages" class="clear-button">Clear Messages</button>      </div>
      <div id="message-list"></div>
    </div>
  </div>

  <script>
    const statusElement = document.getElementById('connection-status');
    const dataContainer = document.getElementById('data-container');
    const messageList = document.getElementById('message-list');
    const phoneContainer = document.getElementById('phone-container');

    // Sensor data display elements
    const accelXElement = document.getElementById('accel-x');
    const accelYElement = document.getElementById('accel-y');
    const accelZElement = document.getElementById('accel-z');

    let ws;

    // Track source IDs
    const sourceIds = new Set();
    let currentSourceId = 'all';
    const sourceIdSelector = document.getElementById('source-id-selector');

    // Last processed sensor data
    let lastSensorData = {
      acceleration: { x: 0, y: 0, z: 0 },
      orientation: { x: 0, y: 0, z: 0, absolute: false, _lastUpdate: 0 }
    };

    // Add a variable to track calibration state from server
    let serverCalibrationActive = false;

    // Punch visualization elements
    const punchBarElement = document.getElementById('current-punch-strength');
    const lastPunchValueElement = document.getElementById('last-punch-value');
    const lastPunchClassificationElement = document.getElementById('last-punch-classification');

    // Three.js variables
    let scene, camera, renderer, phoneModel;
    let isThreeJsInitialized = false;

    // Message throttling settings
    const messageThrottleTime = 500; // ms between sensor data updates
    let lastAccelerationMessageTime = 0;
    let lastOrientationMessageTime = 0;
    let sensorUpdatesSkipped = 0;

    // Message filter state
    const messageFilters = {
      punch: true,
      system: true,
      error: true,
      acceleration: false,
      orientation: false
    };

    // Add this variable near the top with other state variables
    let lastPunchTime = 0;

    // Add these variables at the top near other state variables
    let calibrationQuaternion = new THREE.Quaternion();
    let inverseCalibrationQuaternion = new THREE.Quaternion();
    let isCalibrated = false;

    // Initialize Three.js
    function initThreeJs() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1C1C1E);

      camera = new THREE.PerspectiveCamera(75, phoneContainer.clientWidth / phoneContainer.clientHeight, 0.1, 1000);
      camera.position.z = 7;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
      phoneContainer.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      createPhoneModel();
      window.addEventListener('resize', onWindowResize);
      animate();
      isThreeJsInitialized = true;
    }

    // Create phone model
    function createPhoneModel() {
      const phoneGroup = new THREE.Group();
      scene.add(phoneGroup);

      // Phone body
      const phoneGeometry = new THREE.BoxGeometry(2, 4, 0.2);
      const phoneMaterial = new THREE.MeshPhongMaterial({
        color: 0x333333,
        shininess: 30
      });
      phoneModel = new THREE.Mesh(phoneGeometry, phoneMaterial);
      phoneGroup.add(phoneModel);

      // Phone screen - place it slightly in front to be visible
      const screenGeometry = new THREE.BoxGeometry(1.8, 3.6, 0.01);
      const screenMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a1a,
        shininess: 100
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.11;
      phoneModel.add(screen);

      // Add a marker for the top of the phone to help with orientation
      const topMarkerGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.25);
      const topMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const topMarker = new THREE.Mesh(topMarkerGeometry, topMarkerMaterial);
      topMarker.position.y = 2.05;
      topMarker.position.z = 0.02;
      phoneModel.add(topMarker);

      // Store the phone group for rotation updates
      phoneModel.userData.phoneGroup = phoneGroup;

      // Add coordinate axes to visualize orientation
      addDeviceCoordinateAxes(phoneGroup);
    }

    // Add coordinate axes to visualize device orientation
    function addDeviceCoordinateAxes(group) {
      const axisLength = 2.0;
      const axisWidth = 0.05;
      const axesGroup = new THREE.Group();
      group.add(axesGroup);

      // X-axis (red) - right/left
      const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
      xAxis.rotation.z = -Math.PI / 2; // Align with device x-axis
      xAxis.position.x = axisLength / 2;
      axesGroup.add(xAxis);

      const xTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const xTip = new THREE.Mesh(xTipGeometry, xAxisMaterial);
      xTip.rotation.z = -Math.PI / 2;
      xTip.position.x = axisLength;
      axesGroup.add(xTip);

      // Y-axis (green) - up/down
      const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
      yAxis.position.y = axisLength / 2;
      axesGroup.add(yAxis);

      const yTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const yTip = new THREE.Mesh(yTipGeometry, yAxisMaterial);
      yTip.position.y = axisLength;
      axesGroup.add(yTip);

      // Z-axis (blue) - toward/away from screen
      const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
      const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
      zAxis.rotation.x = Math.PI / 2; // Align with device z-axis
      zAxis.position.z = axisLength / 2;
      axesGroup.add(zAxis);

      const zTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const zTip = new THREE.Mesh(zTipGeometry, zAxisMaterial);
      zTip.rotation.x = Math.PI / 2;
      zTip.position.z = axisLength;
      axesGroup.add(zTip);

      // Add labels
      axesGroup.add(createLabel('X', new THREE.Vector3(axisLength + 0.3, 0, 0), '#ff0000'));
      axesGroup.add(createLabel('Y', new THREE.Vector3(0, axisLength + 0.3, 0), '#00ff00'));
      axesGroup.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.3), '#0000ff'));

      // Add rotation descriptors
      axesGroup.add(createLabel('α', new THREE.Vector3(0, 0, axisLength + 0.6), '#0000ff', 'Z-axis'));
      axesGroup.add(createLabel('β', new THREE.Vector3(axisLength + 0.6, 0, 0), '#ff0000', 'X-axis'));
      axesGroup.add(createLabel('γ', new THREE.Vector3(0, axisLength + 0.6, 0), '#00ff00', 'Y-axis'));
    }

    // Modify the createLabel function to include optional description
    function createLabel(text, position, color, description = '') {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.font = 'Bold 64px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 64, 54);

      if (description) {
        context.font = '24px Arial';
        context.fillText(description, 64, 90);
      }

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.5, 0.5);
      sprite.position.copy(position);
      return sprite;
    }

    // Window resize handler
    function onWindowResize() {
      if (!isThreeJsInitialized) return;
      camera.aspect = phoneContainer.clientWidth / phoneContainer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/debug`;

      console.log('Connecting to WebSocket at:', wsUrl);

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusElement.textContent = 'Connected';
        statusElement.classList.remove('disconnected');
        statusElement.classList.add('connected');
        addMessage({ type: 'system', message: 'Connected to server' });

        if (!isThreeJsInitialized) {
          initThreeJs();
        }

        // Request current configuration from server
        requestConfig();
      };

      ws.onclose = () => {
        statusElement.textContent = 'Disconnected - Reconnecting in 5 seconds...';
        statusElement.classList.remove('connected');
        statusElement.classList.add('disconnected');
        addMessage({ type: 'system', message: 'Disconnected from server' });
        setTimeout(connect, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addMessage({ type: 'error', message: 'WebSocket error occurred' });
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          processMessage(data);
          addMessage(data);
        } catch (error) {
          console.error('Error parsing message:', error);
          addMessage({ type: 'error', message: 'Error parsing message' });
        }
      };
    }

    function requestConfig() {
      // Try to get config via REST API first
      fetch('/api/config')
        .then(response => response.json())
        .then(data => {
          if (data && data.punch) {
            updateFormWithConfig(data.punch);
            addMessage({ type: 'system', message: 'Loaded configuration from REST API' });
          } else {
            // Fallback to WebSocket
            requestConfigViaWebSocket();
          }
        })
        .catch(error => {
          console.error('Error fetching config via REST:', error);
          // Fallback to WebSocket
          requestConfigViaWebSocket();
        });
    }

    function requestConfigViaWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'getConfig' }));
      }
    }

    function updateFormWithConfig(punchConfig) {
      // Update all configuration form values
      document.getElementById('weak-threshold').value = punchConfig.weakThreshold || 3;
      document.getElementById('normal-threshold').value = punchConfig.normalThreshold || 6;
      document.getElementById('strong-threshold').value = punchConfig.strongThreshold || 15;
      document.getElementById('punch-cooldown').value = punchConfig.coolDown || 100;
      document.getElementById('punch-max-value').value = punchConfig.maxValue || 40;
      document.getElementById('min-punch-threshold').value = punchConfig.minThreshold || 2;
      document.getElementById('accel-weight-x').value = punchConfig.accelWeights?.x || 1.0;
      document.getElementById('accel-weight-y').value = punchConfig.accelWeights?.y || 1.0;
      document.getElementById('accel-weight-z').value = punchConfig.accelWeights?.z || 1.0;
      document.getElementById('direction-filter-enabled').value =
        (punchConfig.directionFilter?.enabled !== undefined) ?
          punchConfig.directionFilter.enabled.toString() : "true";
      document.getElementById('direction-tolerance').value = punchConfig.directionFilter?.tolerance || 45;
      document.getElementById('preferred-direction').value = punchConfig.directionFilter?.direction || "positive-x";

      // Add new photo scrolling configuration
      document.getElementById('scroll-base-multiplier').value = punchConfig.photoScroll?.baseMultiplier || 1.0;
      document.getElementById('scroll-scaling-factor').value = punchConfig.photoScroll?.scalingFactor || 0.2;
      document.getElementById('scroll-max-photos').value = punchConfig.photoScroll?.maxPhotos || 10;

      // Update the visual indicators
      updatePunchThresholds();
    }

    function processMessage(data) {
      // Track source ID if present
      if (data.sourceId && data.sourceId !== '') {
        if (!sourceIds.has(data.sourceId)) {
          sourceIds.add(data.sourceId);
          updateSourceIdDropdown();
        }
      }

      // Filter messages by source ID if not set to "all"
      if (currentSourceId !== 'all' &&
        (currentSourceId === 'unclassified'
          ? (data.sourceId && data.sourceId !== '')  // If unclassified selected, skip if has sourceId
          : data.sourceId !== currentSourceId)) {    // Otherwise, skip if doesn't match current
        return; // Skip processing this message
      }

      // Check if the message is sensor data (acceleration or orientation)
      if (data.type === 'acceleration' && data.acceleration) {
        lastSensorData.acceleration = {
          x: data.acceleration.x,
          y: data.acceleration.y,
          z: data.acceleration.z
        };

        accelXElement.textContent = lastSensorData.acceleration.x.toFixed(2);
        accelYElement.textContent = lastSensorData.acceleration.y.toFixed(2);
        accelZElement.textContent = lastSensorData.acceleration.z.toFixed(2);
      }
      else if (data.type === 'orientation' && data.orientation) {
        processOrientationData(data.orientation);
        updatePhoneVisualization();
      }
      // Handle punch data
      else if (data.type === 'punch') {
        const now = Date.now();
        const cooldown = parseInt(document.getElementById('punch-cooldown').value);

        // Only process punch if outside cooldown period
        if (now - lastPunchTime >= cooldown) {
          lastPunchTime = now;

          lastPunchValueElement.textContent = data.acceleration ? data.acceleration.toFixed(2) : 'N/A';
          lastPunchClassificationElement.textContent = data.classification || 'Unknown';
          lastPunchClassificationElement.className = '';
          lastPunchClassificationElement.classList.add(data.classification || 'unknown');

          // Get max value from the input field
          const maxValue = parseFloat(document.getElementById('punch-max-value').value);
          const percentage = Math.min(((data.acceleration || 0) / maxValue) * 100, 100);
          punchBarElement.style.width = `${percentage}%`;

          punchBarElement.className = 'punch-bar';
          if (data.classification) {
            punchBarElement.classList.add(data.classification);
          }

          punchBarElement.style.transition = 'width 0.1s linear';
          setTimeout(() => {
            punchBarElement.style.transition = 'width 2s ease-in-out';
            punchBarElement.style.width = '0%';
          }, 100);
        } else {
          // Optionally log or show a message about ignored punch due to cooldown
          console.log(`Punch ignored due to cooldown (${now - lastPunchTime}ms < ${cooldown}ms)`);
        }
      }
      // Handle system message with config update
      else if (data.type === 'system' && data.punchConfig) {
        updateFormWithConfig(data.punchConfig);
      }
    }

    // Process orientation data to handle edge cases
    function processOrientationData(orientation) {
      lastSensorData.orientation = {
        x: orientation.x,
        y: orientation.y,
        z: orientation.z,
        absolute: orientation.absolute,
        _lastUpdate: Date.now()
      };

      // Update the absolute flag display
      document.getElementById('orientation-absolute').textContent = orientation.absolute;
    }

    function updatePhoneVisualization() {
      if (!isThreeJsInitialized || !phoneModel) return;

      const phoneGroup = phoneModel.userData.phoneGroup;
      if (!phoneGroup) return;

      // Get the orientation values
      const alpha = lastSensorData.orientation.x;
      const beta = lastSensorData.orientation.y;
      const gamma = lastSensorData.orientation.z;

      // Convert to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // 1. Create Euler angles with ZXY order to match device orientation spec
      const deviceRotation = new THREE.Euler(betaRad, gammaRad, alphaRad, 'ZXY');

      // 2. Create quaternion from the Euler rotation
      const deviceQuaternion = new THREE.Quaternion();
      deviceQuaternion.setFromEuler(deviceRotation);

      // 3. Apply the standard offset to make phone face user (beta = 90°)
      // This puts the phone in portrait orientation facing the user
      const baseOrientation = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(Math.PI / 2, 0, 0)
      );

      // Reset quaternion first
      phoneGroup.quaternion.identity();

      // 4. Apply the base orientation first
      phoneGroup.quaternion.copy(baseOrientation);

      // 5. If calibrated, apply calibration offset
      if (isCalibrated) {
        // Apply the inverse calibration quaternion (the offset)
        phoneGroup.quaternion.multiply(inverseCalibrationQuaternion);
      }

      // 6. Then apply device orientation
      phoneGroup.quaternion.multiply(deviceQuaternion);
    }

    // Add this function to calibrate the orientation
    function calibratePhoneVisualization() {
      if (!isThreeJsInitialized || !phoneModel) return;

      const phoneGroup = phoneModel.userData.phoneGroup;
      if (!phoneGroup) return;

      // Get the current orientation values
      const alpha = lastSensorData.orientation.x;
      const beta = lastSensorData.orientation.y;
      const gamma = lastSensorData.orientation.z;

      // Convert to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // Create the device quaternion from current orientation
      const deviceQuaternion = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(betaRad, gammaRad, alphaRad, 'ZXY')
      );

      // Store the current device quaternion as our calibration quaternion
      calibrationQuaternion.copy(deviceQuaternion);

      // Create the inverse quaternion to use as an offset
      inverseCalibrationQuaternion.copy(calibrationQuaternion).invert();

      // Set calibration flag
      isCalibrated = true;

      // Update the visualization immediately
      updatePhoneVisualization();

      addMessage({
        type: 'system',
        message: `Orientation calibrated at α=${alpha.toFixed(1)}°, β=${beta.toFixed(1)}°, γ=${gamma.toFixed(1)}°`
      });
    }

    function addMessage(data) {
      const now = Date.now();

      // Throttle frequent sensor data messages
      if (data.type === 'acceleration') {
        if (now - lastAccelerationMessageTime < messageThrottleTime) {
          sensorUpdatesSkipped++;
          return;
        }
        lastAccelerationMessageTime = now;
        if (sensorUpdatesSkipped > 0) {
          sensorUpdatesSkipped = 0;
        }
      } else if (data.type === 'orientation') {
        if (now - lastOrientationMessageTime < messageThrottleTime) {
          return;
        }
        lastOrientationMessageTime = now;
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      messageDiv.dataset.type = data.type;

      // Handle sourceId - explicitly set unclassified for messages without sourceId
      if (data.sourceId && data.sourceId !== '') {
        messageDiv.dataset.sourceId = data.sourceId;
      } else {
        messageDiv.dataset.sourceId = 'unclassified';
      }

      // Apply visibility based on current filters
      if (!messageFilters[data.type]) {
        messageDiv.style.display = 'none';
      }

      // Also hide if not matching current source ID filter
      if (currentSourceId !== 'all') {
        const isUnclassified = !data.sourceId || data.sourceId === '';
        if ((currentSourceId === 'unclassified' && !isUnclassified) ||
          (currentSourceId !== 'unclassified' && messageDiv.dataset.sourceId !== currentSourceId)) {
          messageDiv.style.display = 'none';
        }
      }

      const timestamp = data.timestamp || new Date().toISOString();
      let content = '';
      let messageClass = data.type;

      // Add source ID prefix if available, otherwise show as "Unclassified"
      const sourceIdPrefix = data.sourceId && data.sourceId !== ''
        ? `[${data.sourceId}] `
        : '[Unclassified] ';

      if (data.type === 'acceleration') {
        content = `${sourceIdPrefix}Accel: x=${data.acceleration.x.toFixed(2)}, y=${data.acceleration.y.toFixed(2)}, z=${data.acceleration.z.toFixed(2)}`;
      } else if (data.type === 'orientation') {
        content = `${sourceIdPrefix}Orient: α=${data.orientation.x.toFixed(2)}°, β=${data.orientation.y.toFixed(2)}°, γ=${data.orientation.z.toFixed(2)}°, abs=${data.orientation.absolute}`;
      } else if (data.type === 'punch') {
        messageClass += data.classification ? ` punch-${data.classification}` : '';
        content = `${sourceIdPrefix}Punch: ${data.classification || ''} (${data.acceleration ? data.acceleration.toFixed(2) : 'N/A'})`;
      } else if (data.type === 'error' && data.message) {
        content = `${sourceIdPrefix}Error: ${data.message}`;
      } else if (data.type === 'system' && data.message) {
        content = `${sourceIdPrefix}${data.message}`;
      } else {
        content = `${sourceIdPrefix}${JSON.stringify(data, null, 2)}`;
      }

      messageDiv.innerHTML = `
        <div class="timestamp">${new Date(timestamp).toLocaleTimeString('en-US', { hour12: false })}</div>
        <div class="message-content ${messageClass}">${content}</div>
      `;

      messageList.insertBefore(messageDiv, messageList.firstChild);

      // Keep only last 100 messages
      if (messageList.children.length > 100) {
        messageList.removeChild(messageList.lastChild);
      }
    }

    // Initial connection
    connect();

    // Setup punch configuration controls
    const applyConfigButton = document.getElementById('apply-config');
    applyConfigButton.addEventListener('click', () => {
      const punchConfig = {
        weakThreshold: parseFloat(document.getElementById('weak-threshold').value),
        normalThreshold: parseFloat(document.getElementById('normal-threshold').value),
        strongThreshold: parseFloat(document.getElementById('strong-threshold').value),
        coolDown: parseInt(document.getElementById('punch-cooldown').value),
        maxValue: parseFloat(document.getElementById('punch-max-value').value),
        minThreshold: parseFloat(document.getElementById('min-punch-threshold').value),
        accelWeights: {
          x: parseFloat(document.getElementById('accel-weight-x').value),
          y: parseFloat(document.getElementById('accel-weight-y').value),
          z: parseFloat(document.getElementById('accel-weight-z').value)
        },
        directionFilter: {
          enabled: document.getElementById('direction-filter-enabled').value === "true",
          tolerance: parseFloat(document.getElementById('direction-tolerance').value),
          direction: document.getElementById('preferred-direction').value
        },
        photoScroll: {
          baseMultiplier: Math.max(0.1, parseFloat(document.getElementById('scroll-base-multiplier').value) || 1.0),
          scalingFactor: Math.max(0.05, parseFloat(document.getElementById('scroll-scaling-factor').value) || 0.2),
          maxPhotos: Math.max(1, parseInt(document.getElementById('scroll-max-photos').value) || 10)
        }
      };

      updatePunchThresholds();

      // Use the REST API endpoint first, fallback to WebSocket if it fails
      fetch('/api/config', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ punch: punchConfig })
      })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            addMessage({ type: 'system', message: 'Punch configuration updated via REST API' });
          } else {
            // Fallback to WebSocket
            sendConfigViaWebSocket(punchConfig);
          }
        })
        .catch(error => {
          console.error('Error updating config via REST:', error);
          // Fallback to WebSocket
          sendConfigViaWebSocket(punchConfig);
        });
    });

    function sendConfigViaWebSocket(punchConfig) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Add logging to see the actual values being sent
        console.log('Sending photo scroll config:', {
          baseMultiplier: punchConfig.photoScroll.baseMultiplier,
          scalingFactor: punchConfig.photoScroll.scalingFactor,
          maxPhotos: punchConfig.photoScroll.maxPhotos
        });

        ws.send(JSON.stringify({
          type: 'config',
          punchConfig
        }));
        addMessage({
          type: 'system',
          message: `Punch configuration sent via WebSocket (Photo scroll: base=${punchConfig.photoScroll.baseMultiplier}, scale=${punchConfig.photoScroll.scalingFactor}, max=${punchConfig.photoScroll.maxPhotos})`
        });
      } else {
        addMessage({ type: 'error', message: 'WebSocket not connected. Cannot send configuration.' });
      }
    }

    // Initialize punch threshold visualization
    updatePunchThresholds();

    // Add input event listeners to update visualizations in real-time
    document.getElementById('weak-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('normal-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('strong-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('punch-max-value').addEventListener('input', updatePunchThresholds);

    // Function to update the punch threshold visualization
    function updatePunchThresholds() {
      const weakThreshold = parseFloat(document.getElementById('weak-threshold').value);
      const normalThreshold = parseFloat(document.getElementById('normal-threshold').value);
      const strongThreshold = parseFloat(document.getElementById('strong-threshold').value);
      const maxValue = parseFloat(document.getElementById('punch-max-value').value);

      const weakIndicator = document.getElementById('weak-threshold-indicator');
      const normalIndicator = document.getElementById('normal-threshold-indicator');
      const strongIndicator = document.getElementById('strong-threshold-indicator');

      weakIndicator.style.left = `${(weakThreshold / maxValue) * 100}%`;
      normalIndicator.style.left = `${(normalThreshold / maxValue) * 100}%`;
      strongIndicator.style.left = `${(strongThreshold / maxValue) * 100}%`;
    }

    // Set up message filter controls
    document.getElementById('filter-punch').addEventListener('change', (e) => {
      messageFilters.punch = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-system').addEventListener('change', (e) => {
      messageFilters.system = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-error').addEventListener('change', (e) => {
      messageFilters.error = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-acceleration').addEventListener('change', (e) => {
      messageFilters.acceleration = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-orientation').addEventListener('change', (e) => {
      messageFilters.orientation = e.target.checked;
      updateMessageVisibility();
    });

    document.getElementById('clear-messages').addEventListener('click', () => {
      messageList.innerHTML = '';
      addMessage({ type: 'system', message: 'Messages cleared' });
    });

    function updateMessageVisibility() {
      const messages = messageList.querySelectorAll('.message');
      messages.forEach(message => {
        const msgType = message.dataset.type;
        const msgSourceId = message.dataset.sourceId || 'unclassified';

        // Check message type filter
        const isVisibleByType = messageFilters[msgType];

        // Check source ID filter
        let isVisibleBySource = false;
        if (currentSourceId === 'all') {
          isVisibleBySource = true;
        } else if (currentSourceId === 'unclassified') {
          isVisibleBySource = (msgSourceId === 'unclassified');
        } else {
          isVisibleBySource = (msgSourceId === currentSourceId);
        }

        message.style.display = (isVisibleByType && isVisibleBySource) ? 'block' : 'none';
      });
    }

    // Add this JavaScript function to update the preview
    function updatePhotoScrollPreview() {
      const baseMultiplier = parseFloat(document.getElementById('scroll-base-multiplier').value);
      const scalingFactor = parseFloat(document.getElementById('scroll-scaling-factor').value);
      const maxPhotos = parseInt(document.getElementById('scroll-max-photos').value);

      const weakThreshold = parseFloat(document.getElementById('weak-threshold').value);
      const normalThreshold = parseFloat(document.getElementById('normal-threshold').value);
      const strongThreshold = parseFloat(document.getElementById('strong-threshold').value);

      // Calculate photos scrolled for each punch type
      function calculatePhotos(strength) {
        const photoCount = Math.min(
          Math.round(baseMultiplier * (1 + strength * scalingFactor)),
          maxPhotos
        );
        return Math.max(1, photoCount); // At least 1 photo
      }

      document.getElementById('weak-photo-count').textContent = calculatePhotos(weakThreshold);
      document.getElementById('normal-photo-count').textContent = calculatePhotos(normalThreshold);
      document.getElementById('strong-photo-count').textContent = calculatePhotos(strongThreshold);
    }

    // Add this to the event listeners for the photo scrolling inputs
    document.getElementById('scroll-base-multiplier').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('scroll-scaling-factor').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('scroll-max-photos').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('weak-threshold').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('normal-threshold').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('strong-threshold').addEventListener('input', updatePhotoScrollPreview);

    // Call this initially to set up the preview
    updatePhotoScrollPreview();

    // Add event listener for the calibrate button
    document.getElementById('calibrate-visualization').addEventListener('click', calibratePhoneVisualization);

    // Add this function to update the source ID dropdown
    function updateSourceIdDropdown() {
      // Preserve the current selection if possible
      const currentSelection = sourceIdSelector.value;

      // Clear and add the "All Sources" and "Unclassified" options
      sourceIdSelector.innerHTML = `
        <option value="all">All Sources</option>
        <option value="unclassified">Unclassified</option>
      `;

      // Add all source IDs
      sourceIds.forEach(id => {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = id;
        sourceIdSelector.appendChild(option);
      });

      // Try to restore the previous selection if it still exists
      if (sourceIdSelector.querySelector(`option[value="${currentSelection}"]`)) {
        sourceIdSelector.value = currentSelection;
      }
    }

    // Add event listener for the source ID selector
    sourceIdSelector.addEventListener('change', function () {
      currentSourceId = this.value;
      addMessage({
        type: 'system',
        message: `Filtering to source ID: ${currentSourceId === 'all' ? 'All Sources' : currentSourceId}`
      });
    });
  </script>
</body>

</html>
  <script>
    function togglePanel(panel) {
      const parent = panel.parentElement;
      parent.classList.toggle("active");
      const icon = panel.querySelector(".toggle-icon");
      icon.textContent = parent.classList.contains("active") ? "−" : "+";
    }
  </script>
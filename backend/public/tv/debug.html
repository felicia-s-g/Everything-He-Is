<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punch Classification Debug</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #FAFAFA;
      display: flex;
      flex-direction: column;
      height: 80vh;
      color: #333;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 20px;
    }

    .visualization-container {
      flex: 1;
      background: white;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h1,
    h2,
    h3 {
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }

    #phone-container {
      width: 100%;
      height: 300px;
      position: relative;
    }

    #data-container {
      flex: 1;
      height: 700px;
      background-color: white;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow-y: auto;
    }

    .status {
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
    }

    .connected {
      background: #E6F4EA;
      color: #256029;
    }

    .disconnected {
      background: #FCE8E6;
      color: #A52714;
    }

    .message {
      padding: 10px;
      border-bottom: 1px solid #EEE;
      word-wrap: break-word;
      font-size: 14px;
      color: #555;
    }

    .timestamp {
      color: #AAA;
      font-size: 12px;
      padding-bottom: 2px;
    }

    .sensor-data {
      display: flex;
      justify-content: space-between;
      margin-top: 24px;
      width: 100%;
      background: #F8F9FA;
      padding: 12px;
      border-radius: 12px;
    }

    .sensor-value {
      text-align: center;
      flex: 1;
    }

    .sensor-value h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      color: #666;
    }

    .sensor-value p {
      margin: 5px 0;
      font-size: 20px;
      font-weight: 600;
      color: #222;
    }

    .config-panel {
      margin-top: 20px;
      padding: 16px;
      background-color: #FFF;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      width: 100%;
    }

    .config-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .config-control {
      flex: 1 1 calc(33.33% - 16px);
      min-width: 150px;
    }

    .config-control label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .config-control input {
      width: 100%;
      padding: 8px;
      border: 1px solid #EEE;
      border-radius: 4px;
    }

    button {
      width: 100%;
      padding: 10px;
      background-color: #007BFF;
      color: #FFF;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 500;
    }

    button:hover {
      background-color: #0069d9;
    }

    .punch-visualization {
      margin-top: 24px;
      padding: 16px;
      background-color: #FFF;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      width: 100%;
    }

    .punch-meter {
      margin-bottom: 16px;
    }

    .punch-scale {
      display: flex;
      justify-content: space-between;
      position: relative;
      height: 30px;
      margin-top: 8px;
    }

    .punch-threshold {
      position: absolute;
      transform: translateX(-50%);
      font-weight: 500;
      font-size: 14px;
      top: 0;
    }

    .punch-threshold.weak {
      color: #28a745;
    }

    .punch-threshold.normal {
      color: #fd7e14;
    }

    .punch-threshold.strong {
      color: #dc3545;
    }

    .punch-bar-container {
      height: 20px;
      background-color: #EEE;
      border-radius: 10px;
      overflow: hidden;
    }

    .punch-bar {
      height: 100%;
      background-color: #007BFF;
      width: 0%;
    }

    .punch-bar.weak {
      background-color: #28a745;
    }

    .punch-bar.normal {
      background-color: #fd7e14;
    }

    .punch-bar.strong {
      background-color: #dc3545;
    }

    .punch-info {
      text-align: center;
    }

    .punch-info .weak {
      color: #28a745;
      font-weight: bold;
    }

    .punch-info .normal {
      color: #fd7e14;
      font-weight: bold;
    }

    .punch-info .strong {
      color: #dc3545;
      font-weight: bold;
    }

    .config-group {
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .config-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: #555;
    }

    .message-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .message-filters {
      display: flex;
      gap: 16px;
    }

    .message-filters label {
      display: flex;
      align-items: center;
    }

    .message-filters label input {
      margin-right: 8px;
    }

    .message-content {
      display: block;
    }

    /* Message type styling */
    .message-content.punch {
      font-weight: 500;
    }

    .message-content.punch-weak {
      color: #28a745;
      font-weight: bold;
    }

    .message-content.punch-normal {
      color: #fd7e14;
      font-weight: bold;
    }

    .message-content.punch-strong {
      color: #dc3545;
      font-weight: bold;
    }

    .message-content.system {
      color: #6c757d;
      font-style: italic;
    }

    .message-content.error {
      color: #dc3545;
      font-weight: bold;
    }

    .message-content.acceleration,
    .message-content.orientation {
      color: #6c757d;
      font-family: monospace;
      font-size: 0.9em;
    }

    /* Clear button styling */
    #clear-messages {
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
    }

    #clear-messages:hover {
      background-color: #5a6268;
    }

    .calibrate-button {
      margin-bottom: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .calibrate-button:hover {
      background-color: #45a049;
    }
  </style>
</head>

<body>
  <h1>Punch Classification Debug</h1>
  <div id="connection-status" class="status disconnected">Disconnected</div>

  <div class="container">
    <div class="visualization-container">
      <h2>Phone Orientation</h2>
      <button id="calibrate-orientation" class="calibrate-button">Calibrate Orientation</button>
      <div id="phone-container"></div>

      <!-- Add this section near the phone container -->
      <div id="calibration-info"
        style="display:none; margin-top: 10px; padding: 8px; border-radius: 4px; background-color: #e6f7ff; border: 1px solid #91d5ff;">
        <p><strong>Calibration Active</strong></p>
        <p>Reference: <span id="calibration-reference">N/A</span></p>
        <p>Time: <span id="calibration-time">N/A</span></p>
      </div>

      <!-- Add calibration guidance UI -->
      <div id="calibration-guide"
        style="display:none; margin-top: 16px; padding: 12px; border-radius: 8px; background-color: #fff3cd; border: 1px solid #ffeeba;">
        <h3 style="text-align: center; margin-bottom: 12px;">Calibration Guide</h3>
        <p style="text-align: center; font-weight: 500;">Position your device as shown below, then press "Confirm
          Calibration"</p>
        <div style="display: flex; justify-content: center; margin: 16px 0;">
          <img id="calibration-image" src="/img/calibration-pose.png" alt="Standard device position"
            style="max-width: 200px; height: auto; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <p id="calibration-instruction" style="text-align: center; margin-bottom: 16px;">
          Hold device upright with screen facing you, top pointing up
        </p>
        <div style="display: flex; justify-content: space-between; gap: 10px;">
          <button id="cancel-calibration" style="flex: 1; background-color: #6c757d;">Cancel</button>
          <button id="confirm-calibration" style="flex: 1; background-color: #28a745;">Confirm Calibration</button>
        </div>
      </div>

      <!-- Punch Configuration Panel -->
      <div class="config-panel">
        <h3>Punch Classification Settings</h3>

        <div class="config-group">
          <div class="config-title">Threshold Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="weak-threshold">Weak Punch Threshold:</label>
              <input type="number" id="weak-threshold" value="3" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="normal-threshold">Normal Punch Threshold:</label>
              <input type="number" id="normal-threshold" value="6" min="0" step="0.5">
            </div>
            <div class="config-control">
              <label for="strong-threshold">Strong Punch Threshold:</label>
              <input type="number" id="strong-threshold" value="15" min="0" step="0.5">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Detection Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="punch-cooldown">Punch Cooldown (ms):</label>
              <input type="number" id="punch-cooldown" value="100" min="0" step="10">
            </div>
            <div class="config-control">
              <label for="punch-max-value">Max Punch Value:</label>
              <input type="number" id="punch-max-value" value="40" min="1" step="1">
            </div>
            <div class="config-control">
              <label for="min-punch-threshold">Minimum Detection Threshold:</label>
              <input type="number" id="min-punch-threshold" value="2" min="0" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Acceleration Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="accel-weight-x">X-axis Weight:</label>
              <input type="number" id="accel-weight-x" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-y">Y-axis Weight:</label>
              <input type="number" id="accel-weight-y" value="1.0" min="0" max="10" step="0.1">
            </div>
            <div class="config-control">
              <label for="accel-weight-z">Z-axis Weight:</label>
              <input type="number" id="accel-weight-z" value="1.0" min="0" max="10" step="0.1">
            </div>
          </div>
        </div>

        <div class="config-group">
          <div class="config-title">Direction Filter</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="direction-filter-enabled">Enable Direction Filter:</label>
              <select id="direction-filter-enabled">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
              </select>
            </div>
            <div class="config-control">
              <label for="direction-tolerance">Direction Tolerance (°):</label>
              <input type="number" id="direction-tolerance" value="45" min="0" max="180" step="5">
            </div>
            <div class="config-control">
              <label for="preferred-direction">Preferred Direction:</label>
              <select id="preferred-direction">
                <option value="positive-x">+X (Right)</option>
                <option value="negative-x">-X (Left)</option>
                <option value="positive-y">+Y (Up)</option>
                <option value="negative-y">-Y (Down)</option>
                <option value="positive-z">+Z (Forward)</option>
                <option value="negative-z">-Z (Backward)</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Add new config group for photo scrolling -->
        <div class="config-group">
          <div class="config-title">Photo Scrolling Settings</div>
          <div class="config-controls">
            <div class="config-control">
              <label for="scroll-base-multiplier">Base Scroll Multiplier:</label>
              <input type="number" id="scroll-base-multiplier" value="1.0" min="0.1" max="10" step="0.1">
              <small>Controls overall scrolling speed for all punch strengths</small>
            </div>
            <div class="config-control">
              <label for="scroll-scaling-factor">Scaling Factor:</label>
              <input type="number" id="scroll-scaling-factor" value="0.2" min="0.05" max="2" step="0.05">
              <small>Controls how punch strength affects number of photos scrolled (higher = more photos per punch
                strength)</small>
            </div>
            <div class="config-control">
              <label for="scroll-max-photos">Maximum Photos:</label>
              <input type="number" id="scroll-max-photos" value="10" min="1" max="50" step="1">
              <small>Maximum number of photos to scroll per punch, regardless of strength</small>
            </div>
          </div>
        </div>

        <button id="apply-config">Apply Configuration</button>
      </div>

      <!-- Punch Classification Visualization -->
      <div class="punch-visualization">
        <h3>Punch Classification Visualization</h3>
        <div class="punch-meter">
          <div class="punch-bar-container">
            <div class="punch-bar" id="current-punch-strength"></div>
            <div class="punch-scale">
              <div class="punch-threshold weak" id="weak-threshold-indicator">Weak</div>
              <div class="punch-threshold normal" id="normal-threshold-indicator">Normal</div>
              <div class="punch-threshold strong" id="strong-threshold-indicator">Strong</div>
            </div>
          </div>
        </div>
        <div class="punch-info">
          <p>Last Punch: <span id="last-punch-value">None</span></p>
          <p>Classification: <span id="last-punch-classification">None</span></p>
        </div>
      </div>

      <div class="punch-visualization">
        <h3>Photo Scrolling Preview</h3>
        <div class="punch-info">
          <p>For a <span class="weak">weak</span> punch: <span id="weak-photo-count">0</span> photos</p>
          <p>For a <span class="normal">normal</span> punch: <span id="normal-photo-count">0</span> photos</p>
          <p>For a <span class="strong">strong</span> punch: <span id="strong-photo-count">0</span> photos</p>
        </div>
      </div>

      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Acceleration X</h3>
          <p id="accel-x">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Y</h3>
          <p id="accel-y">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Z</h3>
          <p id="accel-z">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Orientation Absolute</h3>
          <p id="orientation-absolute">false</p>
        </div>
      </div>

      <!-- Add this near the top of the page body, after the phone container -->
      <div id="orientation-guide" class="config-panel" style="margin-top: 16px;">
        <h3>Device Orientation Guide</h3>
        <div style="display: flex; flex-wrap: wrap; gap: 16px;">
          <div style="flex: 1; min-width: 200px;">
            <h4>Device Axes</h4>
            <ul>
              <li><strong style="color:#ff0000">X-axis (Red):</strong> Left/Right</li>
              <li><strong style="color:#00ff00">Y-axis (Green):</strong> Up/Down</li>
              <li><strong style="color:#0000ff">Z-axis (Blue):</strong> Forward/Backward</li>
            </ul>
          </div>
          <div style="flex: 1; min-width: 200px;">
            <h4>Rotation Angles</h4>
            <ul>
              <li><strong>α (alpha):</strong> Rotation around Z-axis (compass)</li>
              <li><strong>β (beta):</strong> Rotation around X-axis (tilt forward/back)</li>
              <li><strong>γ (gamma):</strong> Rotation around Y-axis (tilt left/right)</li>
            </ul>
          </div>
        </div>
        <div style="margin-top: 10px;">
          <p><small>When the device is in its standard orientation, α=0° points north, β=0° is level with horizon, γ=0°
              is upright.</small></p>
        </div>
      </div>
    </div>

    <div id="data-container">
      <div class="message-controls">
        <div class="message-filters">
          <label>
            <input type="checkbox" id="filter-punch" checked> Punches
          </label>
          <label>
            <input type="checkbox" id="filter-system" checked> System
          </label>
          <label>
            <input type="checkbox" id="filter-error" checked> Errors
          </label>
          <label>
            <input type="checkbox" id="filter-acceleration"> Acceleration
          </label>
          <label>
            <input type="checkbox" id="filter-orientation"> Orientation
          </label>
          <label>
            <input type="checkbox" id="show-normalized" checked> Show Normalized Data
          </label>
        </div>
        <button id="clear-messages">Clear Messages</button>
      </div>
      <div id="message-list"></div>
    </div>
  </div>

  <script>
    const statusElement = document.getElementById('connection-status');
    const dataContainer = document.getElementById('data-container');
    const messageList = document.getElementById('message-list');
    const phoneContainer = document.getElementById('phone-container');

    // Sensor data display elements
    const accelXElement = document.getElementById('accel-x');
    const accelYElement = document.getElementById('accel-y');
    const accelZElement = document.getElementById('accel-z');

    let ws;

    // Last processed sensor data
    let lastSensorData = {
      acceleration: { x: 0, y: 0, z: 0 },
      orientation: { x: 0, y: 0, z: 0, absolute: false, _lastUpdate: 0 }
    };

    // Add a variable to track calibration state from server
    let serverCalibrationActive = false;

    // Punch visualization elements
    const punchBarElement = document.getElementById('current-punch-strength');
    const lastPunchValueElement = document.getElementById('last-punch-value');
    const lastPunchClassificationElement = document.getElementById('last-punch-classification');

    // Three.js variables
    let scene, camera, renderer, phoneModel;
    let isThreeJsInitialized = false;

    // Message throttling settings
    const messageThrottleTime = 500; // ms between sensor data updates
    let lastAccelerationMessageTime = 0;
    let lastOrientationMessageTime = 0;
    let sensorUpdatesSkipped = 0;

    // Message filter state
    const messageFilters = {
      punch: true,
      system: true,
      error: true,
      acceleration: false,
      orientation: false
    };

    // Add this variable near the top with other state variables
    let lastPunchTime = 0;

    // New variables for calibration info
    const calibrationInfoEl = document.getElementById('calibration-info');
    const calibrationReferenceEl = document.getElementById('calibration-reference');
    const calibrationTimeEl = document.getElementById('calibration-time');

    // Add a flag to control whether to show normalized or raw data
    let showNormalizedData = true;

    // Initialize Three.js
    function initThreeJs() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(75, phoneContainer.clientWidth / phoneContainer.clientHeight, 0.1, 1000);
      camera.position.z = 7;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
      phoneContainer.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      createPhoneModel();
      window.addEventListener('resize', onWindowResize);
      animate();
      isThreeJsInitialized = true;
    }

    // Create phone model
    function createPhoneModel() {
      const phoneGroup = new THREE.Group();
      scene.add(phoneGroup);

      // Phone body
      const phoneGeometry = new THREE.BoxGeometry(2, 4, 0.2);
      const phoneMaterial = new THREE.MeshPhongMaterial({
        color: 0x333333,
        shininess: 30
      });
      phoneModel = new THREE.Mesh(phoneGeometry, phoneMaterial);
      phoneGroup.add(phoneModel);

      // Phone screen - place it slightly in front to be visible
      const screenGeometry = new THREE.BoxGeometry(1.8, 3.6, 0.01);
      const screenMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a1a,
        shininess: 100
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.11;
      phoneModel.add(screen);

      // Add a marker for the top of the phone to help with orientation
      const topMarkerGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.25);
      const topMarkerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const topMarker = new THREE.Mesh(topMarkerGeometry, topMarkerMaterial);
      topMarker.position.y = 2.05;
      topMarker.position.z = 0.02;
      phoneModel.add(topMarker);

      // Store the phone group for rotation updates
      phoneModel.userData.phoneGroup = phoneGroup;

      // Add coordinate axes to visualize orientation
      addDeviceCoordinateAxes(phoneGroup);
    }

    // Add coordinate axes to visualize device orientation
    function addDeviceCoordinateAxes(group) {
      const axisLength = 2.0;
      const axisWidth = 0.05;
      const axesGroup = new THREE.Group();
      group.add(axesGroup);

      // X-axis (red) - right/left
      const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
      xAxis.rotation.z = -Math.PI / 2; // Align with device x-axis
      xAxis.position.x = axisLength / 2;
      axesGroup.add(xAxis);

      const xTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const xTip = new THREE.Mesh(xTipGeometry, xAxisMaterial);
      xTip.rotation.z = -Math.PI / 2;
      xTip.position.x = axisLength;
      axesGroup.add(xTip);

      // Y-axis (green) - up/down
      const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
      yAxis.position.y = axisLength / 2;
      axesGroup.add(yAxis);

      const yTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const yTip = new THREE.Mesh(yTipGeometry, yAxisMaterial);
      yTip.position.y = axisLength;
      axesGroup.add(yTip);

      // Z-axis (blue) - toward/away from screen
      const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
      const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
      zAxis.rotation.x = Math.PI / 2; // Align with device z-axis
      zAxis.position.z = axisLength / 2;
      axesGroup.add(zAxis);

      const zTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const zTip = new THREE.Mesh(zTipGeometry, zAxisMaterial);
      zTip.rotation.x = Math.PI / 2;
      zTip.position.z = axisLength;
      axesGroup.add(zTip);

      // Add labels
      axesGroup.add(createLabel('X', new THREE.Vector3(axisLength + 0.3, 0, 0), '#ff0000'));
      axesGroup.add(createLabel('Y', new THREE.Vector3(0, axisLength + 0.3, 0), '#00ff00'));
      axesGroup.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.3), '#0000ff'));

      // Add rotation descriptors
      axesGroup.add(createLabel('α', new THREE.Vector3(0, 0, axisLength + 0.6), '#0000ff', 'Z-axis'));
      axesGroup.add(createLabel('β', new THREE.Vector3(axisLength + 0.6, 0, 0), '#ff0000', 'X-axis'));
      axesGroup.add(createLabel('γ', new THREE.Vector3(0, axisLength + 0.6, 0), '#00ff00', 'Y-axis'));
    }

    // Modify the createLabel function to include optional description
    function createLabel(text, position, color, description = '') {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.font = 'Bold 64px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 64, 54);

      if (description) {
        context.font = '24px Arial';
        context.fillText(description, 64, 90);
      }

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.5, 0.5);
      sprite.position.copy(position);
      return sprite;
    }

    // Window resize handler
    function onWindowResize() {
      if (!isThreeJsInitialized) return;
      camera.aspect = phoneContainer.clientWidth / phoneContainer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/debug`;

      console.log('Connecting to WebSocket at:', wsUrl);

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusElement.textContent = 'Connected';
        statusElement.classList.remove('disconnected');
        statusElement.classList.add('connected');
        addMessage({ type: 'system', message: 'Connected to server' });

        if (!isThreeJsInitialized) {
          initThreeJs();
        }

        // Request current configuration from server
        requestConfig();
      };

      ws.onclose = () => {
        statusElement.textContent = 'Disconnected - Reconnecting in 5 seconds...';
        statusElement.classList.remove('connected');
        statusElement.classList.add('disconnected');
        addMessage({ type: 'system', message: 'Disconnected from server' });
        setTimeout(connect, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addMessage({ type: 'error', message: 'WebSocket error occurred' });
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          processMessage(data);
          addMessage(data);
        } catch (error) {
          console.error('Error parsing message:', error);
          addMessage({ type: 'error', message: 'Error parsing message' });
        }
      };
    }

    function requestConfig() {
      // Try to get config via REST API first
      fetch('/api/config')
        .then(response => response.json())
        .then(data => {
          if (data && data.punch) {
            updateFormWithConfig(data.punch);
            addMessage({ type: 'system', message: 'Loaded configuration from REST API' });
          } else {
            // Fallback to WebSocket
            requestConfigViaWebSocket();
          }
        })
        .catch(error => {
          console.error('Error fetching config via REST:', error);
          // Fallback to WebSocket
          requestConfigViaWebSocket();
        });
    }

    function requestConfigViaWebSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'getConfig' }));
      }
    }

    function updateFormWithConfig(punchConfig) {
      // Update all configuration form values
      document.getElementById('weak-threshold').value = punchConfig.weakThreshold || 3;
      document.getElementById('normal-threshold').value = punchConfig.normalThreshold || 6;
      document.getElementById('strong-threshold').value = punchConfig.strongThreshold || 15;
      document.getElementById('punch-cooldown').value = punchConfig.coolDown || 100;
      document.getElementById('punch-max-value').value = punchConfig.maxValue || 40;
      document.getElementById('min-punch-threshold').value = punchConfig.minThreshold || 2;
      document.getElementById('accel-weight-x').value = punchConfig.accelWeights?.x || 1.0;
      document.getElementById('accel-weight-y').value = punchConfig.accelWeights?.y || 1.0;
      document.getElementById('accel-weight-z').value = punchConfig.accelWeights?.z || 1.0;
      document.getElementById('direction-filter-enabled').value =
        (punchConfig.directionFilter?.enabled !== undefined) ?
          punchConfig.directionFilter.enabled.toString() : "true";
      document.getElementById('direction-tolerance').value = punchConfig.directionFilter?.tolerance || 45;
      document.getElementById('preferred-direction').value = punchConfig.directionFilter?.direction || "positive-x";

      // Add new photo scrolling configuration
      document.getElementById('scroll-base-multiplier').value = punchConfig.photoScroll?.baseMultiplier || 1.0;
      document.getElementById('scroll-scaling-factor').value = punchConfig.photoScroll?.scalingFactor || 0.2;
      document.getElementById('scroll-max-photos').value = punchConfig.photoScroll?.maxPhotos || 10;

      // Update the visual indicators
      updatePunchThresholds();
    }

    function processMessage(data) {
      // Check if the message is sensor data (acceleration or orientation)
      if (data.type === 'acceleration' && data.acceleration) {
        lastSensorData.acceleration = {
          x: data.acceleration.x,
          y: data.acceleration.y,
          z: data.acceleration.z
        };

        accelXElement.textContent = lastSensorData.acceleration.x.toFixed(2);
        accelYElement.textContent = lastSensorData.acceleration.y.toFixed(2);
        accelZElement.textContent = lastSensorData.acceleration.z.toFixed(2);
      }
      else if (data.type === 'orientation' && data.orientation) {
        processOrientationData(data.orientation);
        updatePhoneVisualization();
      }
      // Handle punch data
      else if (data.type === 'punch') {
        const now = Date.now();
        const cooldown = parseInt(document.getElementById('punch-cooldown').value);

        // Only process punch if outside cooldown period
        if (now - lastPunchTime >= cooldown) {
          lastPunchTime = now;

          lastPunchValueElement.textContent = data.acceleration ? data.acceleration.toFixed(2) : 'N/A';
          lastPunchClassificationElement.textContent = data.classification || 'Unknown';
          lastPunchClassificationElement.className = '';
          lastPunchClassificationElement.classList.add(data.classification || 'unknown');

          // Get max value from the input field
          const maxValue = parseFloat(document.getElementById('punch-max-value').value);
          const percentage = Math.min(((data.acceleration || 0) / maxValue) * 100, 100);
          punchBarElement.style.width = `${percentage}%`;

          punchBarElement.className = 'punch-bar';
          if (data.classification) {
            punchBarElement.classList.add(data.classification);
          }

          punchBarElement.style.transition = 'width 0.1s linear';
          setTimeout(() => {
            punchBarElement.style.transition = 'width 2s ease-in-out';
            punchBarElement.style.width = '0%';
          }, 100);
        } else {
          // Optionally log or show a message about ignored punch due to cooldown
          console.log(`Punch ignored due to cooldown (${now - lastPunchTime}ms < ${cooldown}ms)`);
        }
      }
      // Handle system message with config update
      else if (data.type === 'system' && data.punchConfig) {
        updateFormWithConfig(data.punchConfig);
      }

      // Check for calibration status update
      if (data.type === 'system' && data.calibration) {
        serverCalibrationActive = data.calibration.isCalibrated;

        // Update UI to reflect calibration status
        const calibrateButton = document.getElementById('calibrate-orientation');
        calibrateButton.textContent = serverCalibrationActive ?
          'Reset Calibration' : 'Calibrate Orientation';

        // Show/hide and update calibration info panel
        calibrationInfoEl.style.display = serverCalibrationActive ? 'block' : 'none';

        if (serverCalibrationActive && data.calibration.referenceOrientation) {
          const ref = data.calibration.referenceOrientation;
          calibrationReferenceEl.textContent =
            `α=${ref.x.toFixed(1)}°, β=${ref.y.toFixed(1)}°, γ=${ref.z.toFixed(1)}°`;

          calibrationTimeEl.textContent = new Date(data.calibration.timestamp)
            .toLocaleTimeString('en-US', { hour12: false });
        }
      }

      // Highlight normalized orientation data in the visualization
      if (data.type === 'orientation' && data.orientation && data.orientation.normalized) {
        // Add visual indication that this data is calibrated
        // For example, we could highlight the data display or add a marker
        document.getElementById('orientation-absolute').style.fontWeight = 'bold';
        document.getElementById('orientation-absolute').style.color =
          data.orientation.absolute ? '#999' : '#4CAF50';
      } else if (data.type === 'orientation') {
        document.getElementById('orientation-absolute').style.fontWeight = 'normal';
        document.getElementById('orientation-absolute').style.color = '#000';
      }
    }

    // Process orientation data to handle edge cases
    function processOrientationData(orientation) {
      lastSensorData.orientation = {
        x: orientation.x,
        y: orientation.y,
        z: orientation.z,
        absolute: orientation.absolute,
        _lastUpdate: Date.now()
      };

      // Update the absolute flag display
      document.getElementById('orientation-absolute').textContent = orientation.absolute;
    }

    function updatePhoneVisualization() {
      if (!isThreeJsInitialized || !phoneModel) return;

      const phoneGroup = phoneModel.userData.phoneGroup;
      if (!phoneGroup) return;

      // Reset rotation before applying new orientation
      phoneGroup.rotation.set(0, 0, 0);
      phoneGroup.quaternion.identity();

      // Get the orientation values
      const alpha = lastSensorData.orientation.x; // alpha is rotation around z-axis (compass)
      const beta = lastSensorData.orientation.y;  // beta is rotation around x-axis (tilt front/back)
      const gamma = lastSensorData.orientation.z; // gamma is rotation around y-axis (tilt left/right)

      // Convert to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // SIMPLIFIED APPROACH: Use a single combined rotation with proper order

      // 1. Create Euler angles with ZXY order to match device orientation spec
      // Note: THREE.js Euler angle order is REVERSED from the application order
      // So ZXY order means applying Y, then X, then Z
      const deviceRotation = new THREE.Euler(betaRad, gammaRad, alphaRad, 'ZXY');

      // 2. Create quaternion from the Euler rotation
      const deviceQuaternion = new THREE.Quaternion();
      deviceQuaternion.setFromEuler(deviceRotation);

      // 3. Apply the standard offset to make phone face user (beta = 90°)
      // This puts the phone in portrait orientation facing the user
      const baseOrientation = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(Math.PI / 2, 0, 0)
      );

      // 4. Apply the base orientation first, then device orientation
      phoneGroup.quaternion.copy(baseOrientation);
      phoneGroup.quaternion.multiply(deviceQuaternion);

      // Visual indicator for calibrated data
      if (lastSensorData.orientation.normalized) {
        if (phoneModel.material) {
          phoneModel.material.emissive = new THREE.Color(0x00ff00);
          phoneModel.material.emissiveIntensity = 0.2;
        }
        document.getElementById('orientation-absolute').innerHTML =
          lastSensorData.orientation.absolute ? 'true' :
            '<span style="color:#4CAF50;font-weight:bold">Calibrated</span>';
      } else {
        if (phoneModel.material) {
          phoneModel.material.emissive = new THREE.Color(0x000000);
          phoneModel.material.emissiveIntensity = 0;
        }
        document.getElementById('orientation-absolute').textContent =
          lastSensorData.orientation.absolute ? 'true' : 'false';
      }
    }

    function addMessage(data) {
      const now = Date.now();

      // Throttle frequent sensor data messages
      if (data.type === 'acceleration') {
        if (now - lastAccelerationMessageTime < messageThrottleTime) {
          sensorUpdatesSkipped++;
          return;
        }
        lastAccelerationMessageTime = now;
        if (sensorUpdatesSkipped > 0) {
          sensorUpdatesSkipped = 0;
        }
      } else if (data.type === 'orientation') {
        if (now - lastOrientationMessageTime < messageThrottleTime) {
          return;
        }
        lastOrientationMessageTime = now;
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      messageDiv.dataset.type = data.type;

      // Apply visibility based on current filters
      if (!messageFilters[data.type]) {
        messageDiv.style.display = 'none';
      }

      const timestamp = data.timestamp || new Date().toISOString();
      let content = '';
      let messageClass = data.type;

      if (data.type === 'acceleration') {
        content = `Accel: x=${data.acceleration.x.toFixed(2)}, y=${data.acceleration.y.toFixed(2)}, z=${data.acceleration.z.toFixed(2)}`;
      } else if (data.type === 'orientation') {
        content = `Orient: α=${data.orientation.x.toFixed(2)}°, β=${data.orientation.y.toFixed(2)}°, γ=${data.orientation.z.toFixed(2)}°, abs=${data.orientation.absolute}`;
      } else if (data.type === 'punch') {
        messageClass += data.classification ? ` punch-${data.classification}` : '';
        content = `Punch: ${data.classification || ''} (${data.acceleration ? data.acceleration.toFixed(2) : 'N/A'})`;
      } else if (data.type === 'error' && data.message) {
        content = `Error: ${data.message}`;
      } else if (data.type === 'system' && data.message) {
        content = data.message;
      } else {
        content = JSON.stringify(data, null, 2);
      }

      messageDiv.innerHTML = `
        <div class="timestamp">${new Date(timestamp).toLocaleTimeString('en-US', { hour12: false })}</div>
        <div class="message-content ${messageClass}">${content}</div>
      `;

      messageList.insertBefore(messageDiv, messageList.firstChild);

      // Keep only last 100 messages
      if (messageList.children.length > 100) {
        messageList.removeChild(messageList.lastChild);
      }
    }

    // Initial connection
    connect();

    // Setup punch configuration controls
    const applyConfigButton = document.getElementById('apply-config');
    applyConfigButton.addEventListener('click', () => {
      const punchConfig = {
        weakThreshold: parseFloat(document.getElementById('weak-threshold').value),
        normalThreshold: parseFloat(document.getElementById('normal-threshold').value),
        strongThreshold: parseFloat(document.getElementById('strong-threshold').value),
        coolDown: parseInt(document.getElementById('punch-cooldown').value),
        maxValue: parseFloat(document.getElementById('punch-max-value').value),
        minThreshold: parseFloat(document.getElementById('min-punch-threshold').value),
        accelWeights: {
          x: parseFloat(document.getElementById('accel-weight-x').value),
          y: parseFloat(document.getElementById('accel-weight-y').value),
          z: parseFloat(document.getElementById('accel-weight-z').value)
        },
        directionFilter: {
          enabled: document.getElementById('direction-filter-enabled').value === "true",
          tolerance: parseFloat(document.getElementById('direction-tolerance').value),
          direction: document.getElementById('preferred-direction').value
        },
        photoScroll: {
          baseMultiplier: Math.max(0.1, parseFloat(document.getElementById('scroll-base-multiplier').value) || 1.0),
          scalingFactor: Math.max(0.05, parseFloat(document.getElementById('scroll-scaling-factor').value) || 0.2),
          maxPhotos: Math.max(1, parseInt(document.getElementById('scroll-max-photos').value) || 10)
        }
      };

      updatePunchThresholds();

      // Use the REST API endpoint first, fallback to WebSocket if it fails
      fetch('/api/config', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ punch: punchConfig })
      })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            addMessage({ type: 'system', message: 'Punch configuration updated via REST API' });
          } else {
            // Fallback to WebSocket
            sendConfigViaWebSocket(punchConfig);
          }
        })
        .catch(error => {
          console.error('Error updating config via REST:', error);
          // Fallback to WebSocket
          sendConfigViaWebSocket(punchConfig);
        });
    });

    function sendConfigViaWebSocket(punchConfig) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Add logging to see the actual values being sent
        console.log('Sending photo scroll config:', {
          baseMultiplier: punchConfig.photoScroll.baseMultiplier,
          scalingFactor: punchConfig.photoScroll.scalingFactor,
          maxPhotos: punchConfig.photoScroll.maxPhotos
        });

        ws.send(JSON.stringify({
          type: 'config',
          punchConfig
        }));
        addMessage({
          type: 'system',
          message: `Punch configuration sent via WebSocket (Photo scroll: base=${punchConfig.photoScroll.baseMultiplier}, scale=${punchConfig.photoScroll.scalingFactor}, max=${punchConfig.photoScroll.maxPhotos})`
        });
      } else {
        addMessage({ type: 'error', message: 'WebSocket not connected. Cannot send configuration.' });
      }
    }

    // Initialize punch threshold visualization
    updatePunchThresholds();

    // Add input event listeners to update visualizations in real-time
    document.getElementById('weak-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('normal-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('strong-threshold').addEventListener('input', updatePunchThresholds);
    document.getElementById('punch-max-value').addEventListener('input', updatePunchThresholds);

    // Function to update the punch threshold visualization
    function updatePunchThresholds() {
      const weakThreshold = parseFloat(document.getElementById('weak-threshold').value);
      const normalThreshold = parseFloat(document.getElementById('normal-threshold').value);
      const strongThreshold = parseFloat(document.getElementById('strong-threshold').value);
      const maxValue = parseFloat(document.getElementById('punch-max-value').value);

      const weakIndicator = document.getElementById('weak-threshold-indicator');
      const normalIndicator = document.getElementById('normal-threshold-indicator');
      const strongIndicator = document.getElementById('strong-threshold-indicator');

      weakIndicator.style.left = `${(weakThreshold / maxValue) * 100}%`;
      normalIndicator.style.left = `${(normalThreshold / maxValue) * 100}%`;
      strongIndicator.style.left = `${(strongThreshold / maxValue) * 100}%`;
    }

    // Set up message filter controls
    document.getElementById('filter-punch').addEventListener('change', (e) => {
      messageFilters.punch = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-system').addEventListener('change', (e) => {
      messageFilters.system = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-error').addEventListener('change', (e) => {
      messageFilters.error = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-acceleration').addEventListener('change', (e) => {
      messageFilters.acceleration = e.target.checked;
      updateMessageVisibility();
    });
    document.getElementById('filter-orientation').addEventListener('change', (e) => {
      messageFilters.orientation = e.target.checked;
      updateMessageVisibility();
    });

    document.getElementById('clear-messages').addEventListener('click', () => {
      messageList.innerHTML = '';
      addMessage({ type: 'system', message: 'Messages cleared' });
    });

    function updateMessageVisibility() {
      const messages = messageList.querySelectorAll('.message');
      messages.forEach(message => {
        const msgType = message.dataset.type;
        message.style.display = messageFilters[msgType] ? 'block' : 'none';
      });
    }

    // Replace the calibrateOrientation function with the new implementation
    let calibrationMode = false;

    function startCalibration() {
      // Show the calibration guide overlay
      document.getElementById('calibration-guide').style.display = 'block';

      // Set the phone model to the reference pose
      if (phoneModel && phoneModel.userData.phoneGroup) {
        const phoneGroup = phoneModel.userData.phoneGroup;

        // Reset to standard orientation - this shows the target pose
        phoneGroup.rotation.set(0, 0, 0);
        phoneGroup.quaternion.identity();

        // Apply standard position correction (screen facing user, top up)
        const standardPose = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(Math.PI / 2, 0, 0)
        );
        phoneGroup.quaternion.copy(standardPose);

        // Highlight the model to indicate calibration mode
        if (phoneModel.material) {
          phoneModel.userData.originalColor = phoneModel.material.color.clone();
          phoneModel.material.color.set(0x4CAF50); // Green highlight
        }
      }

      calibrationMode = true;
      addMessage({ type: 'system', message: 'Position your device according to the guide image, then confirm calibration' });
    }

    function cancelCalibration() {
      // Hide the calibration guide
      document.getElementById('calibration-guide').style.display = 'none';

      // Reset phone model appearance
      if (phoneModel && phoneModel.material && phoneModel.userData.originalColor) {
        phoneModel.material.color.copy(phoneModel.userData.originalColor);
      }

      calibrationMode = false;
      addMessage({ type: 'system', message: 'Calibration cancelled' });
    }

    function confirmCalibration() {
      if (!lastSensorData.orientation) {
        addMessage({
          type: 'error',
          message: 'Cannot calibrate: No orientation data available. Move your device first.'
        });
        return;
      }

      // Hide the calibration guide
      document.getElementById('calibration-guide').style.display = 'none';

      // Reset phone model appearance
      if (phoneModel && phoneModel.material && phoneModel.userData.originalColor) {
        phoneModel.material.color.copy(phoneModel.userData.originalColor);
      }

      // Send calibration request with current orientation data
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'calibrateOrientation',
          orientation: {
            x: lastSensorData.orientation.x,
            y: lastSensorData.orientation.y,
            z: lastSensorData.orientation.z,
            absolute: lastSensorData.orientation.absolute
          }
        }));

        addMessage({
          type: 'system',
          message: `Calibration with reference orientation: α=${lastSensorData.orientation.x.toFixed(1)}°, β=${lastSensorData.orientation.y.toFixed(1)}°, γ=${lastSensorData.orientation.z.toFixed(1)}°`
        });
      }

      calibrationMode = false;
    }

    function resetCalibration() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'resetCalibration'
        }));
        addMessage({ type: 'system', message: 'Requesting calibration reset...' });
      }
    }

    function calibrateOrientation() {
      if (serverCalibrationActive) {
        // If already calibrated, send reset request
        resetCalibration();
      } else {
        // Start the new guided calibration process
        startCalibration();
      }
    }

    // Setup the calibration button and new confirm/cancel buttons
    document.getElementById('calibrate-orientation').addEventListener('click', calibrateOrientation);
    document.getElementById('confirm-calibration').addEventListener('click', confirmCalibration);
    document.getElementById('cancel-calibration').addEventListener('click', cancelCalibration);

    // Add this JavaScript function to update the preview
    function updatePhotoScrollPreview() {
      const baseMultiplier = parseFloat(document.getElementById('scroll-base-multiplier').value);
      const scalingFactor = parseFloat(document.getElementById('scroll-scaling-factor').value);
      const maxPhotos = parseInt(document.getElementById('scroll-max-photos').value);

      const weakThreshold = parseFloat(document.getElementById('weak-threshold').value);
      const normalThreshold = parseFloat(document.getElementById('normal-threshold').value);
      const strongThreshold = parseFloat(document.getElementById('strong-threshold').value);

      // Calculate photos scrolled for each punch type
      function calculatePhotos(strength) {
        const photoCount = Math.min(
          Math.round(baseMultiplier * (1 + strength * scalingFactor)),
          maxPhotos
        );
        return Math.max(1, photoCount); // At least 1 photo
      }

      document.getElementById('weak-photo-count').textContent = calculatePhotos(weakThreshold);
      document.getElementById('normal-photo-count').textContent = calculatePhotos(normalThreshold);
      document.getElementById('strong-photo-count').textContent = calculatePhotos(strongThreshold);
    }

    // Add this to the event listeners for the photo scrolling inputs
    document.getElementById('scroll-base-multiplier').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('scroll-scaling-factor').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('scroll-max-photos').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('weak-threshold').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('normal-threshold').addEventListener('input', updatePhotoScrollPreview);
    document.getElementById('strong-threshold').addEventListener('input', updatePhotoScrollPreview);

    // Call this initially to set up the preview
    updatePhotoScrollPreview();

    // Add event listener
    document.getElementById('show-normalized').addEventListener('change', (e) => {
      showNormalizedData = e.target.checked;
      addMessage({
        type: 'system',
        message: `Now showing ${showNormalizedData ? 'normalized' : 'raw'} orientation data in visualization`
      });
    });
  </script>
</body>

</html>
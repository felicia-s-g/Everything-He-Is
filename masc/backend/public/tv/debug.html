<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phone Sensor Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #FAFAFA;
      display: flex;
      flex-direction: column;
      height: 80vh;
      color: #333;
    }

    .container {
      display: flex;
      flex: 1;
      gap: 20px;
    }

    .visualization-container {
      flex: 1;
      background: white;
      height: 700px;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }

    #phone-container {
      width: 100%;
      height: 300px;
      position: relative;
    }

    #data-container {
      flex: 1;
      height: 700px;
      background-color: white;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow-y: auto;
    }

    .status {
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
    }

    .connected {
      background: #E6F4EA;
      color: #256029;
    }

    .disconnected {
      background: #FCE8E6;
      color: #A52714;
    }

    .message {
      padding: 10px;
      border-bottom: 1px solid #EEE;
      word-wrap: break-word;
      font-size: 14px;
      color: #555;
    }

    .timestamp {
      color: #AAA;
      font-size: 12px;
      padding-bottom: 2px;
    }

    .sensor-data {
      display: flex;
      justify-content: space-between;
      margin-top: 24px;
      width: 80%;
      background: #F8F9FA;
      padding: 12px;
      border-radius: 12px;
    }

    .sensor-value {
      text-align: center;
      flex: 1;
    }

    .sensor-value h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      color: #666;
    }

    .sensor-value p {
      margin: 5px 0;
      font-size: 20px;
      font-weight: 600;
      color: #222;
    }
  </style>
</head>

<body>
  <h1>Phone Sensor Visualization</h1>
  <div id="connection-status" class="status disconnected">Disconnected</div>

  <div class="container">
    <div class="visualization-container">
      <h2>Phone Orientation</h2>
      <div id="phone-container"></div>
      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Acceleration X</h3>
          <p id="accel-x">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Y</h3>
          <p id="accel-y">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Acceleration Z</h3>
          <p id="accel-z">0.00</p>
        </div>
      </div>
      <div class="sensor-data">
        <div class="sensor-value">
          <h3>Rotation Alpha</h3>
          <p id="rot-alpha">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Rotation Beta</h3>
          <p id="rot-beta">0.00</p>
        </div>
        <div class="sensor-value">
          <h3>Rotation Gamma</h3>
          <p id="rot-gamma">0.00</p>
        </div>
      </div>
    </div>

    <div id="data-container"></div>
  </div>

  <script>
    const statusElement = document.getElementById('connection-status');
    const dataContainer = document.getElementById('data-container');
    const phoneContainer = document.getElementById('phone-container');

    // Sensor data display elements
    const accelXElement = document.getElementById('accel-x');
    const accelYElement = document.getElementById('accel-y');
    const accelZElement = document.getElementById('accel-z');
    const rotAlphaElement = document.getElementById('rot-alpha');
    const rotBetaElement = document.getElementById('rot-beta');
    const rotGammaElement = document.getElementById('rot-gamma');

    let ws;

    // Last processed sensor data
    let lastSensorData = {
      acceleration: { x: 0, y: 0, z: 0 },
      orientation: { x: 0, y: 0, z: 0, _lastUpdate: 0 }
    };

    // Track continuous rotation to avoid flips
    let continuousRotation = {
      alpha: 0,
      beta: 0,
      gamma: 0
    };

    // Three.js variables
    let scene, camera, renderer, phoneModel;
    let isThreeJsInitialized = false;

    // Initialize Three.js
    function initThreeJs() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      // Create camera
      camera = new THREE.PerspectiveCamera(75, phoneContainer.clientWidth / phoneContainer.clientHeight, 0.1, 1000);
      camera.position.z = 7;

      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
      phoneContainer.appendChild(renderer.domElement);

      // Create lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Create phone model (simple rectangular prism)
      createPhoneModel();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);

      // Start animation loop
      animate();

      isThreeJsInitialized = true;
    }

    // Create phone model
    function createPhoneModel() {
      // We'll create a hierarchy:
      // scene -> phoneGroup -> phoneModel + axes
      // This helps us handle rotations correctly

      // Create phone group to handle rotations
      const phoneGroup = new THREE.Group();
      scene.add(phoneGroup);

      // Phone body - Made larger (2x) compared to previous dimensions
      const phoneGeometry = new THREE.BoxGeometry(2, 4, 0.2);
      const phoneMaterial = new THREE.MeshPhongMaterial({
        color: 0x333333,
        shininess: 30
      });
      phoneModel = new THREE.Mesh(phoneGeometry, phoneMaterial);
      phoneGroup.add(phoneModel);

      // Phone screen - Made larger to match new phone size
      const screenGeometry = new THREE.BoxGeometry(1.8, 3.6, 0.01);
      const screenMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a1a,
        shininess: 100
      });
      const screen = new THREE.Mesh(screenGeometry, screenMaterial);
      screen.position.z = 0.11;
      phoneModel.add(screen);

      // Add small camera dot on top
      const cameraDotGeometry = new THREE.CircleGeometry(0.1, 16);
      const cameraDotMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const cameraDot = new THREE.Mesh(cameraDotGeometry, cameraDotMaterial);
      cameraDot.position.set(0, 1.6, 0.11);
      cameraDot.rotation.x = -Math.PI / 2;
      phoneModel.add(cameraDot);

      // Add a small home button at the bottom
      const homeButtonGeometry = new THREE.CircleGeometry(0.16, 16);
      const homeButtonMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
      const homeButton = new THREE.Mesh(homeButtonGeometry, homeButtonMaterial);
      homeButton.position.set(0, -1.6, 0.11);
      homeButton.rotation.x = -Math.PI / 2;
      phoneModel.add(homeButton);

      // Initial orientation of the phone
      // For device orientation alignment:
      // - Phone y-axis is in the direction of the top of the phone
      // - Phone x-axis is in the direction of the right side of the phone
      // - Phone z-axis is perpendicular to the phone screen

      // No initial rotation needed - the phone is already aligned with Three.js coordinates
      // phoneModel.rotation.x = 0;
      // phoneModel.rotation.y = 0;
      // phoneModel.rotation.z = 0;

      // Store the phone group for rotation updates
      phoneModel.userData.phoneGroup = phoneGroup;

      // Add coordinate axes to visualize orientation
      addDeviceCoordinateAxes(phoneGroup);
    }

    // Add coordinate axes to visualize device orientation
    function addDeviceCoordinateAxes(group) {
      const axisLength = 2.0;
      const axisWidth = 0.05;

      // Create a separate group for the axes
      const axesGroup = new THREE.Group();
      group.add(axesGroup);

      // X-axis (red) - points to the right side of the device
      const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
      xAxis.rotation.z = -Math.PI / 2;
      xAxis.position.x = axisLength / 2;
      axesGroup.add(xAxis);

      const xTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const xTip = new THREE.Mesh(xTipGeometry, xAxisMaterial);
      xTip.rotation.z = -Math.PI / 2;
      xTip.position.x = axisLength;
      axesGroup.add(xTip);

      // Y-axis (green) - points to the top of the device
      const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
      yAxis.position.y = axisLength / 2;
      axesGroup.add(yAxis);

      const yTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const yTip = new THREE.Mesh(yTipGeometry, yAxisMaterial);
      yTip.position.y = axisLength;
      axesGroup.add(yTip);

      // Z-axis (blue) - points out from the screen
      const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
      const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
      const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
      zAxis.rotation.x = Math.PI / 2;
      zAxis.position.z = axisLength / 2;
      axesGroup.add(zAxis);

      const zTipGeometry = new THREE.ConeGeometry(axisWidth * 2, axisWidth * 5, 8);
      const zTip = new THREE.Mesh(zTipGeometry, zAxisMaterial);
      zTip.rotation.x = Math.PI / 2;
      zTip.position.z = axisLength;
      axesGroup.add(zTip);

      // Add labels
      axesGroup.add(createLabel('X', new THREE.Vector3(axisLength + 0.3, 0, 0), '#ff0000'));
      axesGroup.add(createLabel('Y', new THREE.Vector3(0, axisLength + 0.3, 0), '#00ff00'));
      axesGroup.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.3), '#0000ff'));
    }

    // Create text label for axes
    function createLabel(text, position, color) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      context.fillStyle = color;
      context.font = 'Bold 48px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, 32, 32);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.5, 0.5);
      sprite.position.copy(position);
      return sprite;
    }

    // Window resize handler
    function onWindowResize() {
      if (!isThreeJsInitialized) return;

      camera.aspect = phoneContainer.clientWidth / phoneContainer.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(phoneContainer.clientWidth, phoneContainer.clientHeight);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/debug`;

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        statusElement.textContent = 'Connected';
        statusElement.classList.remove('disconnected');
        statusElement.classList.add('connected');
        addMessage({ type: 'system', message: 'Connected to server' });

        // Initialize Three.js when connected
        if (!isThreeJsInitialized) {
          initThreeJs();
        }
      };

      ws.onclose = () => {
        statusElement.textContent = 'Disconnected - Reconnecting in 5 seconds...';
        statusElement.classList.remove('connected');
        statusElement.classList.add('disconnected');
        addMessage({ type: 'system', message: 'Disconnected from server' });
        setTimeout(connect, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addMessage({ type: 'error', message: 'WebSocket error occurred' });
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          processMessage(data);
          addMessage(data);
        } catch (error) {
          console.error('Error parsing message:', error);
          addMessage({ type: 'error', message: 'Error parsing message' });
        }
      };
    }

    function processMessage(data) {
      // Check if the message is sensor data (acceleration or orientation)
      if (data.type === 'acceleration' && data.acceleration) {
        // Use raw acceleration values for snappy response
        lastSensorData.acceleration = {
          x: data.acceleration.x,
          y: data.acceleration.y,
          z: data.acceleration.z
        };

        // Update UI display
        accelXElement.textContent = lastSensorData.acceleration.x.toFixed(2);
        accelYElement.textContent = lastSensorData.acceleration.y.toFixed(2);
        accelZElement.textContent = lastSensorData.acceleration.z.toFixed(2);
      }

      // Update orientation data if available
      else if (data.type === 'orientation' && data.orientation) {
        // Process orientation data to handle edge cases
        processOrientationData(data.orientation);

        // Update UI display
        rotAlphaElement.textContent = lastSensorData.orientation.x.toFixed(2);
        rotBetaElement.textContent = lastSensorData.orientation.y.toFixed(2);
        rotGammaElement.textContent = lastSensorData.orientation.z.toFixed(2);

        // Update visualization immediately
        updatePhoneVisualization();
      }
      // Handle punch intensity data
      else if (data.type === 'punch') {
        // Could add visualization for punch intensity here if needed
      }
    }

    // Calculate the shortest rotation between two angles
    function shortestRotation(from, to, range = 360) {
      // For alpha (range 0-360)
      if (range === 360) {
        // Normalize angles to 0-360
        from = ((from % 360) + 360) % 360;
        to = ((to % 360) + 360) % 360;
      }

      // Calculate the difference
      let diff = to - from;

      // Find the shortest path
      if (range === 360) {
        // For alpha (full circle)
        if (diff > 180) {
          diff -= 360;
        } else if (diff < -180) {
          diff += 360;
        }
      } else {
        // For beta and gamma (limited range)
        // Ensure we don't exceed the range limits
        const halfRange = range / 2;
        if (Math.abs(diff) > halfRange) {
          if (diff > 0) {
            diff = range - diff;
          } else {
            diff = -range - diff;
          }
        }
      }

      return diff;
    }

    // Process orientation data to handle edge cases
    function processOrientationData(orientation) {
      const now = Date.now();

      // Initialize if this is the first data point
      if (lastSensorData.orientation._lastUpdate === 0) {
        lastSensorData.orientation = {
          x: orientation.x,
          y: orientation.y,
          z: orientation.z,
          _lastUpdate: now
        };

        // Initialize continuous rotation values
        continuousRotation.alpha = orientation.x;
        continuousRotation.beta = orientation.y;
        continuousRotation.gamma = orientation.z;
        return;
      }

      // Calculate the shortest rotation for each axis
      const alphaDiff = shortestRotation(lastSensorData.orientation.x, orientation.x, 360);
      const betaDiff = shortestRotation(lastSensorData.orientation.y, orientation.y, 180);
      const gammaDiff = shortestRotation(lastSensorData.orientation.z, orientation.z, 180);

      // Update continuous rotation values by adding the shortest rotation
      continuousRotation.alpha += alphaDiff;
      continuousRotation.beta += betaDiff;
      continuousRotation.gamma += gammaDiff;

      // Update with raw values for display
      lastSensorData.orientation = {
        x: orientation.x,
        y: orientation.y,
        z: orientation.z,
        _lastUpdate: now
      };
    }

    function updatePhoneVisualization() {
      if (!isThreeJsInitialized || !phoneModel) return;

      // Get the phone group
      const phoneGroup = phoneModel.userData.phoneGroup;
      if (!phoneGroup) return;

      // Use raw continuous rotation values without calibration
      let alpha = continuousRotation.alpha % 360;
      let beta = continuousRotation.beta;
      let gamma = continuousRotation.gamma;

      // Map alpha to the correct range (0 to 360 degrees)
      if (alpha < 0) alpha += 360;

      // Convert degrees to radians
      const alphaRad = THREE.MathUtils.degToRad(alpha);
      const betaRad = THREE.MathUtils.degToRad(beta);
      const gammaRad = THREE.MathUtils.degToRad(gamma);

      // Reset the phone group's orientation
      phoneGroup.quaternion.set(0, 0, 0, 1);

      // Create a rotation order that matches device orientation spec
      // Device orientation rotations are applied in this order:
      // 1. Alpha (Z-axis) - compass direction
      // 2. Beta (X-axis) - front-to-back tilt
      // 3. Gamma (Y-axis) - left-to-right tilt

      // First, rotate around Z-axis (alpha)
      const qZ = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 0, 1),
        -alphaRad // Negative because the rotation direction is opposite in Three.js
      );

      // Second, rotate around X-axis (beta)
      const qX = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(1, 0, 0),
        -betaRad // Negative because the rotation direction is opposite in Three.js
      );

      // Third, rotate around Y-axis (gamma)
      const qY = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 1, 0),
        gammaRad // No negative because this already aligns with Three.js
      );

      // Apply rotations in the correct order for extrinsic rotations (ZXY)
      // For extrinsic rotations, the multiplication order is REVERSED
      const finalQuaternion = new THREE.Quaternion();
      finalQuaternion.multiply(qY).multiply(qX).multiply(qZ);

      // Apply the final rotation to the phone group
      phoneGroup.quaternion.copy(finalQuaternion);
    }

    function addMessage(data) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';

      const timestamp = data.timestamp || new Date().toISOString();
      let content = '';

      if (data.type === 'acceleration') {
        content = `Acceleration: x=${data.acceleration.x.toFixed(2)}, y=${data.acceleration.y.toFixed(2)}, z=${data.acceleration.z.toFixed(2)}`;
      } else if (data.type === 'orientation') {
        content = `Orientation: alpha=${data.orientation.x.toFixed(2)}°, beta=${data.orientation.y.toFixed(2)}°, gamma=${data.orientation.z.toFixed(2)}°`;
      } else if (data.type === 'punch') {
        const intensity = data.punchIntensity;
        content = `Punch Intensity: ${intensity.toFixed(2)}`;
      } else if (data.type === 'error' && data.message) {
        content = `Error: ${data.message}`;
      } else if (data.type === 'system' && data.message) {
        content = data.message;
      } else {
        content = JSON.stringify(data, null, 2);
      }

      messageDiv.innerHTML = `
        <div class="timestamp">${timestamp}</div>
        <div>${content}</div>
      `;

      dataContainer.insertBefore(messageDiv, dataContainer.firstChild);

      // Keep only last 50 messages
      if (dataContainer.children.length > 50) {
        dataContainer.removeChild(dataContainer.lastChild);
      }
    }

    // Initialize Three.js if user manually reloads the page
    if (!isThreeJsInitialized) {
      window.addEventListener('DOMContentLoaded', () => {
        initThreeJs();
      });
    }

    // Initial connection
    connect();
  </script>
</body>

</html>